{"version":3,"sources":["../../src/form.ts","../../src/hooks.ts","../../src/elements/FormInput.tsx","../../node_modules/babel-plugin-transform-async-to-promises/helpers.js","../../src/yup.ts","../../src/Components.tsx","../../src/elements/FormError.tsx","../../src/elements/FormSelect.tsx","../../src/elements/FormTextArea.tsx","VisualRender.tsx","App.tsx","index.tsx"],"names":["memberCopy","value","Array","Error","comparePrimitiveObject","a","b","ak","Object","bk","lk","i","k","av","bv","FormState","formId","childMap","dirtyMap","errorMap","listeners","anyListeners","counter","this","setValueInternal","isDefault","notifyChild","notifyParent","fireAny","valueMap","child","updateParentValues","fireAnyListeners","validate","validateOnChange","setValue","dirty","values","defaultValues","console","key","setValues","newKeys","localKeys","mostKeys","setDefaultValues","r","e","validateSync","validator","setError","error","updateParentErrors","setErrors","changed","errors","resetAll","reset","setState","c","updateParentState","listen","setters","id","listenAny","ignore","ignoreAny","fireListeners","l","al","ChildFormState","parent","useChildForm","parentForm","name","useRef","useEffect","useListener","form","setRender","useState","defaultValue","state","useAnyListener","append","remove","newValues","clear","move","to","newArr","target","increment","swap","index","newIndex","useArrayForm","oldLength","val","getClassName","args","Symbol","iterator","asyncIterator","yupErrorToErrorMap","errorTransformer","obj","err","pathSegments","o","j","oo","props","React","childForm","oldThruthly","thruthly","FormError","rest","FormInput","style","className","disableOnSubmitting","dateAsNumber","errorClassName","errorStyle","dirtyClassName","dirtyStyle","setUndefinedOnUncheck","setNullOnUncheck","hideWhenNull","inputValue","currentValue","useMemo","inValue","inChecked","n","ni","parseInt","isNaN","d","Date","disabled","checked","onChange","newValue","ev","newChecked","parseFloat","arr","FormSelect","children","FormTextArea","validateOnMount","defaultState","isSubmitting","yupSchema","options","messageTransformer","body","recover","result","then","ex","VisualRender","ref","timeoutRef","current","clearTimeout","window","setTimeout","App","padding","background","color","href","outline","Form","initialValues","Math","ceil","random","description","author","public","date","getTime","dateObject","tags","language","todos","message","priority","TodoListSchema","yup","required","min","useForm","yupValidator","onSubmit","preventDefault","Promise","res","display","gridTemplateColumns","gridTemplateRows","gap","margin","type","render","map","_","TodoItem","onMoveTop","onRemove","onClick","fill","getFullYear","multiple","age","rows","cols","position","top","height","FormValues","fontSize","defaultChecked","show","setShow","overflow","borderRadius","undefined","JSON","stringify","ReactDOM","document","getElementById"],"mappings":"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","file":"static/js/main.c6f55391.chunk.js","sourcesContent":["export type ListenerCallback = () => void;\nexport type ListenerMap = { [T in string]?: ListenerCallback };\nexport type Validator<T, Error> = (values: T) => ErrorMap<T, Error> | Promise<ErrorMap<T, Error>>;\n\nexport type ChildFormMap<T, State, Error> = {\n    [Key in keyof T]?: ChildFormState<T, State, Error, Key>;\n};\n\nexport type DirtyMap<T> = {\n    [Key in keyof T]?: boolean;\n};\n\ntype ObjectOrArray = {\n    [key: string]: any;\n    [key: number]: any;\n};\n\nexport type ErrorType<T, Error> = T extends ObjectOrArray ? ErrorMap<T, Error> | Error : Error;\n\nexport type ErrorMap<T, Error> = {\n    [Key in keyof T]?: ErrorType<T[Key], Error>;\n};\n\nexport type DefaultError = string;\nexport type DefaultState = { isSubmitting: boolean };\n\nexport function memberCopy<T>(value: T): T {\n    if (Array.isArray(value)) {\n        return [...value] as any;\n    } else if (typeof value === \"object\") {\n        return { ...value };\n    } else {\n        throw new Error(\"Can only memberCopy() arrays and objects.\");\n    }\n}\n\n/**\n * Compares 2 objects that only contain primitive fields (no object fields)\n * @returns true when different, false when 'equal', undefined when an object field was found.\n */\nexport function comparePrimitiveObject<T>(a: T, b: T): boolean | undefined {\n    // Compare null and undefined\n    if (!a || !b) return a === b;\n    let ak = Object.keys(a),\n        bk = Object.keys(b);\n    let lk = ak.length > bk.length ? ak : bk;\n    for (let i = 0; i < lk.length; i++) {\n        let k = lk[i];\n        let av = a[k],\n            bv = b[k];\n        if ((typeof av === \"object\" && av !== null) || (typeof bv === \"object\" && bv !== null)) return undefined;\n        if (av !== bv) return true;\n    }\n    return false;\n}\n\nexport class FormState<T, State = DefaultState, Error = DefaultError> {\n    /**\n     * The id of this form, for debugging purposes.\n     */\n    public readonly formId = ++FormState.formCounter;\n\n    /**\n     * The form's validator.\n     */\n    public validator?: Validator<T, Error>;\n\n    /**\n     * Should the form validate on each value change?\n     */\n    public validateOnChange: boolean;\n    public validateOnMount: boolean;\n\n    /**\n     * The values on this form. Use setValues() to set these.\n     */\n    public readonly values: T;\n\n    /**\n     * The default values on this form. Use setDefaultValues(...) to set these.\n     */\n    public readonly defaultValues: T;\n\n    /**\n     * The dictionary that maps object fields to child forms.\n     */\n    public readonly childMap: ChildFormMap<T, State, Error> = {};\n\n    /**\n     * The dictionary that contains dirty states for each field.\n     */\n    public readonly dirtyMap: DirtyMap<T> = {};\n\n    /**\n     * The dictionary that contains errors for each field.\n     */\n    public readonly errorMap: ErrorMap<T, Error> = {};\n\n    private _state: State;\n    private listeners: { [Key in keyof T]?: ListenerMap } = {};\n    private anyListeners: ListenerMap = {};\n    private counter = 0;\n    private static formCounter = 0;\n\n    public constructor(\n        values: T,\n        defaultValues: T,\n        defaultState: State,\n        validator: Validator<T, Error> | undefined,\n        validateOnMount: boolean,\n        validateOnChange: boolean\n    ) {\n        this.values = memberCopy(values);\n        this.defaultValues = memberCopy(defaultValues);\n        this._state = memberCopy(defaultState);\n        this.validator = validator;\n        this.validateOnMount = validateOnMount;\n        this.validateOnChange = validateOnChange;\n    }\n\n    /**\n     * Gets the state of the current form.\n     */\n    public get state() {\n        return this._state;\n    }\n\n    /**\n     * Is this form modified?\n     */\n    public get dirty() {\n        return Object.keys(this.dirtyMap).some((e) => this.dirtyMap[e]);\n    }\n\n    /**\n     * Does this form contain any error?\n     */\n    public get error() {\n        return Object.keys(this.errorMap).some((e) => this.errorMap[e]);\n    }\n\n    /**\n     * Sets a value the advanced way.\n     * @param key The field to set.\n     * @param value The value to set in the field.\n     * @param dirty Is this field dirty? Leave undefined to not set any dirty value. (can always be overridden by child forms)\n     * @param validate Should the form validate after value set? This does not override `validateOnChange`.\n     * @param isDefault Is this the default value for the said field?\n     * @param notifyChild Should this form notify any child form about the change?\n     * @param notifyParent Should this form notify any parent form about the change?\n     * @param setValuesWasUsed Fire all `anyListeners` after field is set? You should not touch this. (will be false for bulk sets, they will call fireAnyListeners() after every field is set)\n     */\n    public setValueInternal<Key extends keyof T>(\n        key: Key,\n        value: T[Key] | undefined,\n        dirty: boolean,\n        validate?: boolean,\n        isDefault: boolean = false,\n        notifyChild: boolean = true,\n        notifyParent: boolean = true,\n        fireAny: boolean = true\n    ) {\n        let valueMap = isDefault ? this.defaultValues : this.values;\n        if (value === undefined) {\n            if (Array.isArray(valueMap)) valueMap.splice(key as number, 1);\n            else delete valueMap[key];\n        } else {\n            valueMap[key] = value;\n        }\n\n        this.dirtyMap[key] = dirty;\n\n        if (notifyChild) {\n            let child = this.childMap[key];\n            if (child && value !== undefined && value !== null) {\n                child.setValues(value!, true, isDefault, true, false);\n                this.dirtyMap[key] = child.dirty;\n            }\n        }\n\n        this.fireListeners(key);\n        if (notifyParent) this.updateParentValues(isDefault); // Will call setValueInternal on parent\n        if (fireAny) this.fireAnyListeners(); // Will be false when using setValues, he will call fireAnyListeners and notifyParentValues itself\n\n        if (validate ?? (this.validateOnChange && this.validator)) this.validate();\n    }\n\n    /**\n     * Set a value on this form.\n     * @param key The field to set.\n     * @param value The field's new value.\n     * @param validate Should the form validate?\n     * @param isDefault Is this the default value?\n     * @param notifyChild Should this form notify the child form about this change?\n     * @param notifyParent Should this form notify the parent form about this change?\n     * @param setValuesWasUsed Fire all `anyListeners` after field is set? You should not touch this. (will be false for bulk sets, they will call fireAnyListeners() after every field is set)\n     */\n    public setValue<Key extends keyof T>(\n        key: Key,\n        value: T[Key] | undefined,\n        validate?: boolean,\n        isDefault: boolean = false,\n        notifyChild: boolean = true,\n        notifyParent: boolean = true,\n        fireAny: boolean = true\n    ) {\n        // value can contain the default value or normal value. (Determined by isDefault)\n        if (typeof value === \"object\" && value !== null) {\n            let dirty: boolean | undefined = false;\n            if (value instanceof Date) {\n                // Compare date objects\n                dirty = value?.getTime() !== (isDefault ? this.values[key] : (this.defaultValues[key] as any))?.getTime();\n            } else if (fireAny) {\n                // Compare primitive objects (objects containing only primitive fields), but only is setValues was not used (dirty value will be determined by child forms)\n                dirty = comparePrimitiveObject(value, isDefault ? this.values[key] : this.defaultValues[key]); // Is switched intentionally\n                if (dirty === undefined) {\n                    console.warn(\n                        \"Do not use setValue for object in object fields, use setValueInternal instead (dirty value can not be determined), \",\n                        key,\n                        value\n                    );\n                    dirty = true;\n                }\n            }\n\n            this.setValueInternal(key, value, dirty, validate, isDefault, notifyChild, notifyParent, fireAny);\n        } else {\n            // Compare value and existing value/defaultValue which determines dirty\n            let dirty = isDefault ? value !== this.values[key] : value !== this.defaultValues[key];\n\n            // Do not set if already set\n            if (((isDefault && this.defaultValues[key] === value) || (!isDefault && this.values[key] === value)) && this.dirtyMap[key] === dirty) {\n                return;\n            }\n\n            this.setValueInternal(key, value, dirty, validate, isDefault, notifyChild, notifyParent, fireAny);\n        }\n    }\n\n    /**\n     * Set all values OR default values on this form.\n     * @param values The new values to set on this form.\n     * @param validate Validate? Does not override `validateOnChange`.\n     * @param isDefault Are these values the default values for this form? This function only updates values or defaultValues, not both! To set both, use `form.setDefaultValues()`.\n     * @param notifyChild Should this form notify the child form about this change?\n     * @param notifyParent Should this form notify the parent form about this change?\n     */\n    public setValues(values: T, validate?: boolean, isDefault: boolean = false, notifyChild: boolean = true, notifyParent: boolean = true) {\n        // Copy the values to the local form object\n        let newKeys = Object.keys(isDefault ? this.defaultValues : this.values);\n        let localKeys = Object.keys(values);\n        let mostKeys = newKeys.length > localKeys.length ? newKeys : localKeys;\n        for (let i = 0; i < mostKeys.length; i++) {\n            let key = mostKeys[i] as keyof T;\n            this.setValue(\n                key,\n                values[key],\n                false, // Will validate after all values are copied\n                isDefault,\n                notifyChild,\n                false, // Will call updateParentValues by itself after all values are copied, see 3 lines down\n                false // Will call fireAnyListener by itself after all values are copied, see 3 lines down\n            );\n        }\n        if (notifyParent) this.updateParentValues(isDefault);\n        this.fireAnyListeners();\n\n        if (validate ?? (this.validateOnChange && this.validator)) this.validate();\n    }\n\n    /**\n     * Set both values and default values for this form. If you only want to set default values, use `setValues(...,...,true)`.\n     * @param values The new default values to set on this form.\n     * @param validate Validate?\n     * @param notifyChild Should this form notify the child form about this change?\n     * @param notifyParent Should this form notify the parent form about this change?\n     */\n    public setDefaultValues(values: T, validate: boolean = true, notifyChild: boolean = true, notifyParent: boolean = true) {\n        this.setValues(values, false, true, notifyChild, notifyParent);\n        this.setValues(values, validate, false, notifyChild, notifyParent);\n    }\n\n    /**\n     * Force validation on this form. Required when `validateOnChange` is disabled. **This function works with both asynchronous and synchronous validators.**\n     * @returns true if the form is valid.\n     */\n    public async validate() {\n        if (!this.validator) {\n            console.warn(\"validate() was called on a form which does not have a validator set.\");\n            return false;\n        }\n        let r = this.validator(this.values);\n        if (r instanceof Promise) r = await r;\n        this.setErrors(r);\n        return !this.error;\n    }\n\n    /**\n     * Force validation on this form. Required when `validateOnChange` is disabled. **This only works if you have a synchronous validator set (not async).**\n     * @returns true if the form is valid.\n     */\n    public validateSync() {\n        if (!this.validator) {\n            console.warn(\"validate() was called on a form which does not have a validator set.\");\n            return false;\n        }\n        let r = this.validator(this.values);\n        if (r instanceof Promise)\n            throw new Error(\"validateSync() was called on a form with an asynchronous validator set, please use `await form.validate()` instead.\");\n        this.setErrors(r);\n        return !this.error;\n    }\n\n    /**\n     * Sets an error on this form\n     * @param key The field to set an error on.\n     * @param error The error.\n     * @param notifyChild Should this form notify the child form about this change?\n     * @param notifyParent Should this form notify the parent form about this change?\n     * @param setValuesWasUsed\n     */\n    public setError<Key extends keyof T>(\n        key: Key,\n        error: ErrorType<T[Key], Error> | undefined,\n        notifyChild: boolean = true,\n        notifyParent: boolean = true,\n        fireAny: boolean = true\n    ) {\n        if (typeof error !== \"object\" && this.errorMap[key] === error) return false;\n\n        if (!error) delete this.errorMap[key];\n        else this.errorMap[key] = error;\n\n        if (notifyChild && this.childMap[key]) {\n            let changed = !this.childMap[key]!.setErrors((typeof error === \"object\" ? error ?? {} : {}) as any, true, false);\n            // Only return if the object changed, when a string error was given, this should not return\n            if (changed && typeof error === \"object\") return false;\n        }\n\n        this.fireListeners(key);\n        if (notifyParent) this.updateParentErrors(); // Will call setError on parent\n        if (fireAny) this.fireAnyListeners(); // When setValuesWasUsed, it will call fireAnyListener itself when all values were set\n        return true;\n    }\n\n    /**\n     * Sets all the errors on this form.\n     * @param errors The new errors for this form. Use {} to clear errors. **The format of this error object must follow the same structure of the values object, but each value is replaced by its error.**\n     * @param notifyChild Should this form notify the child form about this change?\n     * @param notifyParent Should this form notify the parent form about this change?\n     */\n    public setErrors(errors: ErrorMap<T, Error>, notifyChild: boolean = true, notifyParent: boolean = true) {\n        let localKeys = Object.keys(this.errorMap);\n        let newKeys = Object.keys(errors);\n        let mostKeys = newKeys.length > localKeys.length ? newKeys : localKeys;\n        let changed = false;\n        for (let i = 0; i < mostKeys.length; i++) {\n            let key = mostKeys[i] as keyof T;\n            changed =\n                changed ||\n                this.setError(\n                    key,\n                    errors[key] as any,\n                    notifyChild,\n                    false, // Will call updateParentErrors by itself after all values have been copied, see 3 lines down\n                    false // Will call fireAnyListener by itself after all values have been copied, see 3 lines down\n                );\n        }\n        if (!changed) return false;\n        if (notifyParent) this.updateParentErrors();\n        this.fireAnyListeners();\n        return true;\n    }\n\n    /**\n     * Reset this form's values to the default values.\n     * @param notifyChild Should this form notify the child form about this change?\n     * @param notifyParent Should this form notify the parent form about this change?\n     */\n    public resetAll(validate?: boolean, notifyChild: boolean = true, notifyParent: boolean = true) {\n        this.setValues(this.defaultValues, validate ?? true, false, notifyChild, notifyParent);\n    }\n\n    /**\n     * Reset a form's field to its default value.\n     * @param key The field to reset.\n     * @param notifyChild Should this form notify the child form about this change?\n     * @param notifyParent Should this form notify the parent form about this change?\n     */\n    public reset(key: keyof T, validate?: boolean, notifyChild: boolean = true, notifyParent: boolean = true) {\n        this.setValue(key, this.defaultValues[key], validate ?? true, false, notifyChild, notifyParent);\n    }\n\n    /**\n     * Sets the state for this form, and also on child and parent forms by default.\n     * @param newState The new form state.\n     * @param notifyChild Set the state on the child too?\n     * @param notifyParent Set the state on the parent too?\n     */\n    public setState(newState: State, notifyChild: boolean = true, notifyParent: boolean = true) {\n        this._state = newState;\n\n        let c = Object.keys(this.values);\n        if (notifyChild) c.forEach((e) => this.childMap[e]?.setState(newState, notifyChild, notifyParent));\n\n        c.forEach((e) => this.fireListeners(e as keyof T));\n        if (notifyParent) this.updateParentState();\n        this.fireAnyListeners();\n    }\n\n    /**\n     * Listen for changes on a field, will trigger when value, defaultValue, dirty and error changes for a field. Make sure you pass its return value back to `ignore()` after you are done listening.\n     * @param key The field to listen to.\n     * @param listener Change callback.\n     */\n    public listen(key: keyof T, listener: ListenerCallback): string {\n        if (!this.listeners) this.listeners = {};\n        let setters = this.listeners[key];\n        if (!setters) {\n            setters = {};\n            this.listeners[key] = setters;\n        }\n        let id = \"\" + this.counter++;\n        setters[id] = listener;\n        return id;\n    }\n\n    /**\n     * Listen for any change on this form. Make sure you pass its return value back to `ignoreAny()` after you are done listening.\n     * @param listener Change callback.\n     */\n    public listenAny(listener: ListenerCallback) {\n        if (!this.anyListeners) this.anyListeners = {};\n        let id = \"\" + this.counter++;\n        this.anyListeners[id] = listener;\n        return id;\n    }\n\n    /**\n     * Ignore changes on a field.\n     * @param key The field to ignore.\n     * @param id The callback to ignore.\n     */\n    public ignore(key: keyof T, id: string) {\n        if (!this.listeners) return;\n        let setters = this.listeners[key];\n        if (!setters) {\n            console.warn(\"Ignore was called for no reason\", key, id);\n            return;\n        }\n        delete setters[id];\n    }\n\n    /**\n     * Ignore changes on this form.\n     * @param id The callback to ignore.\n     */\n    public ignoreAny(id: string) {\n        if (!this.anyListeners) return;\n        delete this.anyListeners[id];\n    }\n\n    protected fireListeners(key: keyof T) {\n        let a = this.listeners[key];\n        if (a) {\n            let l = Object.keys(a!);\n            l.forEach((e) => a![e]!());\n        }\n    }\n\n    protected fireAnyListeners() {\n        let al = Object.keys(this.anyListeners);\n        al.forEach((e) => this.anyListeners[e]!());\n    }\n\n    protected updateParentValues(_isDefault: boolean) {\n        // Not implemented for root form, as it does not have a parent\n    }\n\n    protected updateParentErrors() {\n        // Not implemented for root form, as it does not have a parent\n    }\n\n    protected updateParentState() {\n        // Not implemented for root form, as it does not have a parent\n    }\n}\n\nexport class ChildFormState<Parent, ParentState, ParentError, Key extends keyof Parent> extends FormState<\n    NonNullable<Parent[Key]>,\n    ParentState,\n    ParentError\n> {\n    public name: Key;\n    public readonly parent: FormState<Parent, ParentState, ParentError>;\n\n    public constructor(parent: FormState<Parent, ParentState, ParentError>, name: Key) {\n        super(\n            parent.values[name] ?? ({} as any),\n            parent.defaultValues[name] ?? ({} as any),\n            parent.state,\n            undefined,\n            parent.validateOnMount,\n            parent.validateOnChange\n        );\n        this.parent = parent;\n        this.name = name;\n    }\n\n    protected updateParentValues(isDefault: boolean) {\n        this.parent.setValueInternal(\n            this.name,\n            isDefault ? memberCopy(this.defaultValues) : memberCopy(this.values),\n            this.dirty,\n            true,\n            isDefault,\n            false,\n            true,\n            true\n        );\n    }\n\n    protected updateParentErrors() {\n        this.parent.setError(this.name, this.error ? (memberCopy(this.errorMap) as any) : undefined, false, true);\n    }\n\n    protected updateParentState() {\n        this.parent.setState(memberCopy(this.state), false, true);\n    }\n}\n","import { useRef, useEffect, useState } from \"react\";\nimport { DefaultState, DefaultError, FormState, ChildFormState, Validator } from \"./form\";\n\n/**\n * Creates a new root form.\n * This hook doesn't cause a rerender.\n * @param defaultValues The default values for this form.\n * @param validator The validator to use, optional.\n * @param validateOnChange Validate on change? Optional, default is false.\n * @param validateOnChange Validate on mount? Optional, default is false.\n * @param defaultState The default state for this form. Form state contains custom global states, example: isSubmitting, isLoading ... Optional, default is `{ isSubmitting: false }`.\n */\nexport function useForm<T, State = DefaultState, Error = DefaultError>(\n    defaultValues: T,\n    validator?: Validator<T, Error>,\n    validateOnChange = false,\n    validateOnMount = false,\n    defaultState?: State\n) {\n    let c = useRef<FormState<T, State, Error> | null>(null);\n\n    if (!c.current) {\n        c.current = new FormState(\n            defaultValues,\n            defaultValues,\n            defaultState ?? ({ isSubmitting: false } as any),\n            validator,\n            validateOnMount,\n            validateOnChange\n        );\n    }\n\n    useEffect(() => {\n        c.current!.setDefaultValues(defaultValues, c.current!.validateOnMount, true, false);\n    }, [defaultValues]);\n\n    return c.current;\n}\n\n/**\n * Creates a nested form for another root or nested form. You must use this for object and array (see useArrayForm) field.\n * This hook doesn't cause a rerender.\n * @param parentForm The parent form.\n * @param name The parent's field to create a child form for.\n */\nexport function useChildForm<T, State, Error, Key extends keyof T>(parentForm: FormState<T, State, Error>, name: Key) {\n    let c = useRef<ChildFormState<T, State, Error, Key> | null>(null);\n    if (!c.current) {\n        c.current = new ChildFormState(parentForm, name);\n    }\n\n    useEffect(() => {\n        // Update parent and child form\n        parentForm.childMap[name] = c.current!;\n        c.current!.name = name;\n\n        // First, set new default values, without validating\n        c.current!.setValues(parentForm.defaultValues[name] ?? ({} as any), false, true, true, false);\n        // Then, set new values and validate if needed\n        c.current!.setValues(parentForm.values[name] ?? ({} as any), c.current!.validateOnMount, false, true, false);\n\n        return () => {\n            // Could already be overriden (useEffect ordering)\n            if (parentForm.childMap[name] === c.current!) {\n                delete parentForm.childMap[name];\n                delete parentForm.errorMap[name];\n                delete parentForm.dirtyMap[name];\n            }\n        };\n    }, [parentForm, name]);\n\n    return c.current;\n}\n\n/**\n * Listen for changes on a form's field. Behaves like useState.\n * You shouldn't use this hook in large components, as it rerenders each time something changes. Use the wrapper <Listener /> instead.\n * @param form The form to listen on.\n * @param name The form's field to listen to.\n */\nexport function useListener<T, State, Error, Key extends keyof T>(form: FormState<T, State, Error>, name: Key) {\n    const [, setRender] = useState(0);\n\n    useEffect(() => {\n        let id = form.listen(name, () => {\n            setRender((e) => e + 1);\n        });\n        return () => form.ignore(name, id);\n    }, [form, name]);\n\n    return {\n        value: form.values[name],\n        defaultValue: form.defaultValues[name],\n        setValue: (value: T[Key]) => form.setValue(name, value),\n        dirty: form.dirtyMap[name],\n        error: form.errorMap[name],\n        state: form.state,\n        form\n    };\n}\n\n/**\n * Listens for any change on this form. Behaves like useState.\n * You shouldn't use this hook in large components, as it rerenders each time something changes. Use the wrapper <AnyListener /> instead.\n * @param form The form to listen to.\n */\nexport function useAnyListener<T, State, Error>(form: FormState<T, State, Error>) {\n    const [, setRender] = useState(0);\n\n    useEffect(() => {\n        let id = form.listenAny(() => {\n            setRender((e) => e + 1);\n        });\n        return () => form.ignoreAny(id);\n    }, [form]);\n\n    return form;\n}\n\nfunction append<T, Key extends keyof T>(this: FormState<T, any, any>, value: NonNullable<T[Key]>[keyof NonNullable<T[Key]>]) {\n    this.setValues([...(this.values as any), value] as any);\n}\n\nfunction remove(this: FormState<any, any, any>, index: number) {\n    let newValues = [...this.values];\n    newValues.splice(index, 1);\n    this.setValues(newValues);\n}\n\nfunction clear(this: FormState<any, any, any>) {\n    this.setValues([]);\n}\n\nfunction move(this: FormState<any, any, any>, from: number, to: number) {\n    if (to === from) return;\n    let newArr = [...this.values];\n    var target = newArr[from];\n    var increment = to < from ? -1 : 1;\n    for (var k = from; k !== to; k += increment) {\n        newArr[k] = newArr[k + increment];\n    }\n    newArr[to] = target;\n    this.setValues(newArr);\n}\n\nfunction swap(this: FormState<any, any, any>, index: number, newIndex: number) {\n    if (index === newIndex) {\n        return;\n    }\n    let values = [...this.values];\n    [values[index], values[newIndex]] = [values[newIndex], values[index]];\n    this.setValues(values);\n}\n\n/**\n * This is a wrapper around useChildForm, with useful functions to manipulate arrays.\n * This hook does cause a rerender, but only if the array size changes.\n * @param parentForm The parent form.\n * @param name The parent's field to create a child form for.\n */\nexport function useArrayForm<Parent, ParentState, ParentError, Key extends keyof Parent>(\n    parentForm: FormState<Parent, ParentState, ParentError>,\n    name: Key\n) {\n    const form = useChildForm<Parent, ParentState, ParentError, Key>(parentForm, name);\n    const oldLength = useRef(-1);\n    const [, setRender] = useState(0);\n\n    // Only rerender when array size changed\n    useEffect(() => {\n        let id = parentForm.listen(name, () => {\n            let val = parentForm.values[name] as any;\n            if (val.length !== oldLength.current) {\n                setRender((i) => i + 1);\n                oldLength.current = val.length;\n            }\n        });\n        return () => parentForm.ignore(name, id);\n    }, []);\n\n    return {\n        remove: remove.bind(form),\n        move: move.bind(form),\n        swap: swap.bind(form),\n        clear: clear.bind(form),\n        append: append.bind(form),\n        form: form,\n        values: form.values,\n        setValues: form.setValues.bind(form)\n    };\n}\n","import React, { useMemo } from \"react\";\nimport { InputHTMLAttributes } from \"react\";\nimport { DefaultState, FormState } from \"../form\";\nimport { useListener } from \"../hooks\";\n\ntype BaldInputProps = Omit<InputHTMLAttributes<HTMLInputElement>, \"name\" | \"form\" | \"value\">;\n\nexport const DEFAULT_DIRTY_CLASS = \"typed-form-dirty\";\nexport const DEFAULT_ERROR_CLASS = \"typed-form-error\";\n\nexport function getClassName(...args: any) {\n    return [...args].filter((e) => !!e).join(\" \");\n}\n\nexport type FormInputCheckMode = \"normal\" | \"setNull\" | \"setUndefined\";\n\nexport type FormInputProps<T, State, Error, Key extends keyof T, Value extends T[Key] | T[Key][keyof T[Key]]> = BaldInputProps & {\n    form: FormState<T, State, Error>;\n    name: Key;\n    value?: Value;\n    errorClassName?: string;\n    errorStyle?: React.CSSProperties;\n    dirtyClassName?: string;\n    dirtyStyle?: React.CSSProperties;\n    disableOnSubmitting?: boolean;\n    dateAsNumber?: boolean;\n    setNullOnUncheck?: boolean;\n    setUndefinedOnUncheck?: boolean;\n    hideWhenNull?: boolean;\n};\n\nexport function FormInput<T, State extends DefaultState, Error, Key extends keyof T, Value extends T[Key] | T[Key][keyof T[Key]]>({\n    form,\n    name,\n    style,\n    className,\n    disableOnSubmitting,\n    dateAsNumber,\n    errorClassName,\n    errorStyle,\n    dirtyClassName,\n    dirtyStyle,\n    setUndefinedOnUncheck,\n    setNullOnUncheck,\n    hideWhenNull,\n    value: inputValue,\n    checked: inputChecked,\n    ...rest\n}: FormInputProps<T, State, Error, Key, Value>) {\n    const { value: currentValue, error, dirty, state, setValue, defaultValue } = useListener(form, name);\n\n    let [inValue, inChecked] = useMemo(() => {\n        let inValue = undefined,\n            inChecked = undefined;\n        switch (rest.type) {\n            case \"number\": {\n                inValue = (currentValue ?? \"\") + \"\";\n                break;\n            }\n            case \"datetime-local\":\n            case \"date\": {\n                let n = currentValue as any;\n                if (typeof n === \"string\") {\n                    let ni = parseInt(n);\n                    if (!isNaN(ni)) n = ni;\n                }\n                let d = new Date(n);\n                if (d.getTime() === d.getTime()) {\n                    // Trick to check if date is valid: NaN === NaN returns false\n                    inValue = d?.toISOString().split(\"T\")[0] ?? \"\";\n                } else {\n                    inValue = \"\";\n                }\n                break;\n            }\n            case \"radio\": {\n                inChecked = currentValue === inputValue;\n                break;\n            }\n            case \"checkbox\": {\n                if (setNullOnUncheck) {\n                    inChecked = currentValue !== null;\n                } else if (setUndefinedOnUncheck) {\n                    inChecked = currentValue !== undefined;\n                } else if (inputValue !== undefined) {\n                    inChecked = (Array.isArray(currentValue) ? currentValue : []).includes(inputValue as never);\n                } else {\n                    inChecked = !!currentValue;\n                }\n                break;\n            }\n            default: {\n                inValue = (currentValue ?? \"\") + \"\";\n                break;\n            }\n        }\n        return [inValue, inChecked];\n    }, [rest.type, currentValue, inputValue]);\n\n    if (hideWhenNull && (currentValue === null || currentValue === undefined)) return null;\n\n    if ((setNullOnUncheck || setUndefinedOnUncheck) && rest.type !== \"checkbox\")\n        console.warn(\"setNullOnUncheck/setUndefinedOnUncheck only has an effect on checkboxes.\");\n\n    return (\n        <input\n            style={{\n                ...style,\n                ...(dirty && dirtyStyle),\n                ...(error && errorStyle)\n            }}\n            className={getClassName(className, dirty && (dirtyClassName ?? DEFAULT_DIRTY_CLASS), error && (errorClassName ?? DEFAULT_ERROR_CLASS))}\n            disabled={(disableOnSubmitting ?? true) && state.isSubmitting}\n            value={inValue}\n            checked={inChecked}\n            onChange={(ev) => {\n                let newValue = ev.target.value;\n                let newChecked = ev.target.checked;\n                switch (rest.type) {\n                    case \"number\": {\n                        setValue(parseFloat(newValue) as any);\n                        return;\n                    }\n                    case \"datetime-local\":\n                    case \"date\": {\n                        if (newValue) {\n                            let d = new Date(newValue);\n                            setValue((dateAsNumber ? d.getTime() : d) as any);\n                        } else {\n                            setValue(null as any);\n                        }\n                        return;\n                    }\n                    case \"radio\": {\n                        // Enum field\n                        if (newChecked) {\n                            setValue(inputValue as any);\n                        }\n                        return;\n                    }\n                    case \"checkbox\": {\n                        if (setNullOnUncheck || setUndefinedOnUncheck) {\n                            if (newChecked && inputValue === undefined && !defaultValue)\n                                console.warn(\n                                    \"Toggling checkbox using setNullOnUncheck got checked but a value to set was not found, please provide the value prop\"\n                                );\n                            setValue(\n                                newChecked ? (inputValue !== undefined ? inputValue : defaultValue) : ((setNullOnUncheck ? null : undefined) as any)\n                            );\n                        } else if (inputValue !== undefined) {\n                            // Primitive array field\n                            let arr = Array.isArray(currentValue) ? [...currentValue] : [];\n                            if (newChecked) arr.push(inputValue);\n                            else arr.splice(arr.indexOf(inputValue), 1);\n                            setValue(arr as any);\n                        } else {\n                            // Boolean field\n                            setValue(newChecked as any);\n                        }\n                        return;\n                    }\n                    default: {\n                        // String field\n                        setValue(newValue as any);\n                        return;\n                    }\n                }\n            }}\n            name={name as string}\n            {...rest}\n        />\n    );\n}\n","// A type of promise-like that resolves synchronously and supports only one observer\nexport const _Pact = /*#__PURE__*/(function() {\n\tfunction _Pact() {}\n\t_Pact.prototype.then = function(onFulfilled, onRejected) {\n\t\tconst result = new _Pact();\n\t\tconst state = this.s;\n\t\tif (state) {\n\t\t\tconst callback = state & 1 ? onFulfilled : onRejected;\n\t\t\tif (callback) {\n\t\t\t\ttry {\n\t\t\t\t\t_settle(result, 1, callback(this.v));\n\t\t\t\t} catch (e) {\n\t\t\t\t\t_settle(result, 2, e);\n\t\t\t\t}\n\t\t\t\treturn result;\n\t\t\t} else {\n\t\t\t\treturn this;\n\t\t\t}\n\t\t}\n\t\tthis.o = function(_this) {\n\t\t\ttry {\n\t\t\t\tconst value = _this.v;\n\t\t\t\tif (_this.s & 1) {\n\t\t\t\t\t_settle(result, 1, onFulfilled ? onFulfilled(value) : value);\n\t\t\t\t} else if (onRejected) {\n\t\t\t\t\t_settle(result, 1, onRejected(value));\n\t\t\t\t} else {\n\t\t\t\t\t_settle(result, 2, value);\n\t\t\t\t}\n\t\t\t} catch (e) {\n\t\t\t\t_settle(result, 2, e);\n\t\t\t}\n\t\t};\n\t\treturn result;\n\t}\n\treturn _Pact;\n})();\n\n// Settles a pact synchronously\nexport function _settle(pact, state, value) {\n\tif (!pact.s) {\n\t\tif (value instanceof _Pact) {\n\t\t\tif (value.s) {\n\t\t\t\tif (state & 1) {\n\t\t\t\t\tstate = value.s;\n\t\t\t\t}\n\t\t\t\tvalue = value.v;\n\t\t\t} else {\n\t\t\t\tvalue.o = _settle.bind(null, pact, state);\n\t\t\t\treturn;\n\t\t\t}\n\t\t}\n\t\tif (value && value.then) {\n\t\t\tvalue.then(_settle.bind(null, pact, state), _settle.bind(null, pact, 2));\n\t\t\treturn;\n\t\t}\n\t\tpact.s = state;\n\t\tpact.v = value;\n\t\tconst observer = pact.o;\n\t\tif (observer) {\n\t\t\tobserver(pact);\n\t\t}\n\t}\n}\n\nexport function _isSettledPact(thenable) {\n\treturn thenable instanceof _Pact && thenable.s & 1;\n}\n\n// Converts argument to a function that always returns a Promise\nexport function _async(f) {\n\treturn function() {\n\t\tfor (var args = [], i = 0; i < arguments.length; i++) {\n\t\t\targs[i] = arguments[i];\n\t\t}\n\t\ttry {\n\t\t\treturn Promise.resolve(f.apply(this, args));\n\t\t} catch(e) {\n\t\t\treturn Promise.reject(e);\n\t\t}\n\t}\n}\n\n// Awaits on a value that may or may not be a Promise (equivalent to the await keyword in ES2015, with continuations passed explicitly)\nexport function _await(value, then, direct) {\n\tif (direct) {\n\t\treturn then ? then(value) : value;\n\t}\n\tif (!value || !value.then) {\n\t\tvalue = Promise.resolve(value);\n\t}\n\treturn then ? value.then(then) : value;\n}\n\n// Awaits on a value that may or may not be a Promise, then ignores it\nexport function _awaitIgnored(value, direct) {\n\tif (!direct) {\n\t\treturn value && value.then ? value.then(_empty) : Promise.resolve();\n\t}\n}\n\n// Proceeds after a value has resolved, or proceeds immediately if the value is not thenable\nexport function _continue(value, then) {\n\treturn value && value.then ? value.then(then) : then(value);\n}\n\n// Proceeds after a value has resolved, or proceeds immediately if the value is not thenable\nexport function _continueIgnored(value) {\n\tif (value && value.then) {\n\t\treturn value.then(_empty);\n\t}\n}\n\n// Asynchronously iterate through an object that has a length property, passing the index as the first argument to the callback (even as the length property changes)\nexport function _forTo(array, body, check) {\n\tvar i = -1, pact, reject;\n\tfunction _cycle(result) {\n\t\ttry {\n\t\t\twhile (++i < array.length && (!check || !check())) {\n\t\t\t\tresult = body(i);\n\t\t\t\tif (result && result.then) {\n\t\t\t\t\tif (_isSettledPact(result)) {\n\t\t\t\t\t\tresult = result.v;\n\t\t\t\t\t} else {\n\t\t\t\t\t\tresult.then(_cycle, reject || (reject = _settle.bind(null, pact = new _Pact(), 2)));\n\t\t\t\t\t\treturn;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (pact) {\n\t\t\t\t_settle(pact, 1, result);\n\t\t\t} else {\n\t\t\t\tpact = result;\n\t\t\t}\n\t\t} catch (e) {\n\t\t\t_settle(pact || (pact = new _Pact()), 2, e);\n\t\t}\n\t}\n\t_cycle();\n\treturn pact;\n}\n\n// Asynchronously iterate through an object's properties (including properties inherited from the prototype)\n// Uses a snapshot of the object's properties\nexport function _forIn(target, body, check) {\n\tvar keys = [];\n\tfor (var key in target) {\n\t\tkeys.push(key);\n\t}\n\treturn _forTo(keys, function(i) { return body(keys[i]); }, check);\n}\n\n// Asynchronously iterate through an object's own properties (excluding properties inherited from the prototype)\n// Uses a snapshot of the object's properties\nexport function _forOwn(target, body, check) {\n\tvar keys = [];\n\tfor (var key in target) {\n\t\tif (Object.prototype.hasOwnProperty.call(target, key)) {\n\t\t\tkeys.push(key);\n\t\t}\n\t}\n\treturn _forTo(keys, function(i) { return body(keys[i]); }, check);\n}\n\nexport const _iteratorSymbol = /*#__PURE__*/ typeof Symbol !== \"undefined\" ? (Symbol.iterator || (Symbol.iterator = Symbol(\"Symbol.iterator\"))) : \"@@iterator\";\n\n// Asynchronously iterate through an object's values\n// Uses for...of if the runtime supports it, otherwise iterates until length on a copy\nexport function _forOf(target, body, check) {\n\tif (typeof target[_iteratorSymbol] === \"function\") {\n\t\tvar iterator = target[_iteratorSymbol](), step, pact, reject;\n\t\tfunction _cycle(result) {\n\t\t\ttry {\n\t\t\t\twhile (!(step = iterator.next()).done && (!check || !check())) {\n\t\t\t\t\tresult = body(step.value);\n\t\t\t\t\tif (result && result.then) {\n\t\t\t\t\t\tif (_isSettledPact(result)) {\n\t\t\t\t\t\t\tresult = result.v;\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tresult.then(_cycle, reject || (reject = _settle.bind(null, pact = new _Pact(), 2)));\n\t\t\t\t\t\t\treturn;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif (pact) {\n\t\t\t\t\t_settle(pact, 1, result);\n\t\t\t\t} else {\n\t\t\t\t\tpact = result;\n\t\t\t\t}\n\t\t\t} catch (e) {\n\t\t\t\t_settle(pact || (pact = new _Pact()), 2, e);\n\t\t\t}\n\t\t}\n\t\t_cycle();\n\t\tif (iterator.return) {\n\t\t\tvar _fixup = function(value) {\n\t\t\t\ttry {\n\t\t\t\t\tif (!step.done) {\n\t\t\t\t\t\titerator.return();\n\t\t\t\t\t}\n\t\t\t\t} catch(e) {\n\t\t\t\t}\n\t\t\t\treturn value;\n\t\t\t}\n\t\t\tif (pact && pact.then) {\n\t\t\t\treturn pact.then(_fixup, function(e) {\n\t\t\t\t\tthrow _fixup(e);\n\t\t\t\t});\n\t\t\t}\n\t\t\t_fixup();\n\t\t}\n\t\treturn pact;\n\t}\n\t// No support for Symbol.iterator\n\tif (!(\"length\" in target)) {\n\t\tthrow new TypeError(\"Object is not iterable\");\n\t}\n\t// Handle live collections properly\n\tvar values = [];\n\tfor (var i = 0; i < target.length; i++) {\n\t\tvalues.push(target[i]);\n\t}\n\treturn _forTo(values, function(i) { return body(values[i]); }, check);\n}\n\nexport const _asyncIteratorSymbol = /*#__PURE__*/ typeof Symbol !== \"undefined\" ? (Symbol.asyncIterator || (Symbol.asyncIterator = Symbol(\"Symbol.asyncIterator\"))) : \"@@asyncIterator\";\n\n// Asynchronously iterate on a value using it's async iterator if present, or its synchronous iterator if missing\nexport function _forAwaitOf(target, body, check) {\n\tif (typeof target[_asyncIteratorSymbol] === \"function\") {\n\t\tvar pact = new _Pact();\n\t\tvar iterator = target[_asyncIteratorSymbol]();\n\t\titerator.next().then(_resumeAfterNext).then(void 0, _reject);\n\t\treturn pact;\n\t\tfunction _resumeAfterBody(result) {\n\t\t\tif (check && check()) {\n\t\t\t\treturn _settle(pact, 1, iterator.return ? iterator.return().then(function() { return result; }) : result);\n\t\t\t}\n\t\t\titerator.next().then(_resumeAfterNext).then(void 0, _reject);\n\t\t}\n\t\tfunction _resumeAfterNext(step) {\n\t\t\tif (step.done) {\n\t\t\t\t_settle(pact, 1);\n\t\t\t} else {\n\t\t\t\tPromise.resolve(body(step.value)).then(_resumeAfterBody).then(void 0, _reject);\n\t\t\t}\n\t\t}\n\t\tfunction _reject(error) {\n\t\t\t_settle(pact, 2, iterator.return ? iterator.return().then(function() { return error; }) : error);\n\t\t}\n\t}\n\treturn Promise.resolve(_forOf(target, function(value) { return Promise.resolve(value).then(body); }, check));\n}\n\n// Asynchronously implement a generic for loop\nexport function _for(test, update, body) {\n\tvar stage;\n\tfor (;;) {\n\t\tvar shouldContinue = test();\n\t\tif (_isSettledPact(shouldContinue)) {\n\t\t\tshouldContinue = shouldContinue.v;\n\t\t}\n\t\tif (!shouldContinue) {\n\t\t\treturn result;\n\t\t}\n\t\tif (shouldContinue.then) {\n\t\t\tstage = 0;\n\t\t\tbreak;\n\t\t}\n\t\tvar result = body();\n\t\tif (result && result.then) {\n\t\t\tif (_isSettledPact(result)) {\n\t\t\t\tresult = result.s;\n\t\t\t} else {\n\t\t\t\tstage = 1;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tif (update) {\n\t\t\tvar updateValue = update();\n\t\t\tif (updateValue && updateValue.then && !_isSettledPact(updateValue)) {\n\t\t\t\tstage = 2;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n\tvar pact = new _Pact();\n\tvar reject = _settle.bind(null, pact, 2);\n\t(stage === 0 ? shouldContinue.then(_resumeAfterTest) : stage === 1 ? result.then(_resumeAfterBody) : updateValue.then(_resumeAfterUpdate)).then(void 0, reject);\n\treturn pact;\n\tfunction _resumeAfterBody(value) {\n\t\tresult = value;\n\t\tdo {\n\t\t\tif (update) {\n\t\t\t\tupdateValue = update();\n\t\t\t\tif (updateValue && updateValue.then && !_isSettledPact(updateValue)) {\n\t\t\t\t\tupdateValue.then(_resumeAfterUpdate).then(void 0, reject);\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t}\n\t\t\tshouldContinue = test();\n\t\t\tif (!shouldContinue || (_isSettledPact(shouldContinue) && !shouldContinue.v)) {\n\t\t\t\t_settle(pact, 1, result);\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tif (shouldContinue.then) {\n\t\t\t\tshouldContinue.then(_resumeAfterTest).then(void 0, reject);\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tresult = body();\n\t\t\tif (_isSettledPact(result)) {\n\t\t\t\tresult = result.v;\n\t\t\t}\n\t\t} while (!result || !result.then);\n\t\tresult.then(_resumeAfterBody).then(void 0, reject);\n\t}\n\tfunction _resumeAfterTest(shouldContinue) {\n\t\tif (shouldContinue) {\n\t\t\tresult = body();\n\t\t\tif (result && result.then) {\n\t\t\t\tresult.then(_resumeAfterBody).then(void 0, reject);\n\t\t\t} else {\n\t\t\t\t_resumeAfterBody(result);\n\t\t\t}\n\t\t} else {\n\t\t\t_settle(pact, 1, result);\n\t\t}\n\t}\n\tfunction _resumeAfterUpdate() {\n\t\tif (shouldContinue = test()) {\n\t\t\tif (shouldContinue.then) {\n\t\t\t\tshouldContinue.then(_resumeAfterTest).then(void 0, reject);\n\t\t\t} else {\n\t\t\t\t_resumeAfterTest(shouldContinue);\n\t\t\t}\n\t\t} else {\n\t\t\t_settle(pact, 1, result);\n\t\t}\n\t}\n}\n\n// Asynchronously implement a do ... while loop\nexport function _do(body, test) {\n\tvar awaitBody;\n\tdo {\n\t\tvar result = body();\n\t\tif (result && result.then) {\n\t\t\tif (_isSettledPact(result)) {\n\t\t\t\tresult = result.v;\n\t\t\t} else {\n\t\t\t\tawaitBody = true;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tvar shouldContinue = test();\n\t\tif (_isSettledPact(shouldContinue)) {\n\t\t\tshouldContinue = shouldContinue.v;\n\t\t}\n\t\tif (!shouldContinue) {\n\t\t\treturn result;\n\t\t}\n\t} while (!shouldContinue.then);\n\tconst pact = new _Pact();\n\tconst reject = _settle.bind(null, pact, 2);\n\t(awaitBody ? result.then(_resumeAfterBody) : shouldContinue.then(_resumeAfterTest)).then(void 0, reject);\n\treturn pact;\n\tfunction _resumeAfterBody(value) {\n\t\tresult = value;\n\t\tfor (;;) {\n\t\t\tshouldContinue = test();\n\t\t\tif (_isSettledPact(shouldContinue)) {\n\t\t\t\tshouldContinue = shouldContinue.v;\n\t\t\t}\n\t\t\tif (!shouldContinue) {\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tif (shouldContinue.then) {\n\t\t\t\tshouldContinue.then(_resumeAfterTest).then(void 0, reject);\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tresult = body();\n\t\t\tif (result && result.then) {\n\t\t\t\tif (_isSettledPact(result)) {\n\t\t\t\t\tresult = result.v;\n\t\t\t\t} else {\n\t\t\t\t\tresult.then(_resumeAfterBody).then(void 0, reject);\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t_settle(pact, 1, result);\n\t}\n\tfunction _resumeAfterTest(shouldContinue) {\n\t\tif (shouldContinue) {\n\t\t\tdo {\n\t\t\t\tresult = body();\n\t\t\t\tif (result && result.then) {\n\t\t\t\t\tif (_isSettledPact(result)) {\n\t\t\t\t\t\tresult = result.v;\n\t\t\t\t\t} else {\n\t\t\t\t\t\tresult.then(_resumeAfterBody).then(void 0, reject);\n\t\t\t\t\t\treturn;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tshouldContinue = test();\n\t\t\t\tif (_isSettledPact(shouldContinue)) {\n\t\t\t\t\tshouldContinue = shouldContinue.v;\n\t\t\t\t}\n\t\t\t\tif (!shouldContinue) {\n\t\t\t\t\t_settle(pact, 1, result);\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t} while (!shouldContinue.then);\n\t\t\tshouldContinue.then(_resumeAfterTest).then(void 0, reject);\n\t\t} else {\n\t\t\t_settle(pact, 1, result);\n\t\t}\n\t}\n}\n\n// Asynchronously implement a switch statement\nexport function _switch(discriminant, cases) {\n\tvar dispatchIndex = -1;\n\tvar awaitBody;\n\touter: {\n\t\tfor (var i = 0; i < cases.length; i++) {\n\t\t\tvar test = cases[i][0];\n\t\t\tif (test) {\n\t\t\t\tvar testValue = test();\n\t\t\t\tif (testValue && testValue.then) {\n\t\t\t\t\tbreak outer;\n\t\t\t\t}\n\t\t\t\tif (testValue === discriminant) {\n\t\t\t\t\tdispatchIndex = i;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\t// Found the default case, set it as the pending dispatch case\n\t\t\t\tdispatchIndex = i;\n\t\t\t}\n\t\t}\n\t\tif (dispatchIndex !== -1) {\n\t\t\tdo {\n\t\t\t\tvar body = cases[dispatchIndex][1];\n\t\t\t\twhile (!body) {\n\t\t\t\t\tdispatchIndex++;\n\t\t\t\t\tbody = cases[dispatchIndex][1];\n\t\t\t\t}\n\t\t\t\tvar result = body();\n\t\t\t\tif (result && result.then) {\n\t\t\t\t\tawaitBody = true;\n\t\t\t\t\tbreak outer;\n\t\t\t\t}\n\t\t\t\tvar fallthroughCheck = cases[dispatchIndex][2];\n\t\t\t\tdispatchIndex++;\n\t\t\t} while (fallthroughCheck && !fallthroughCheck());\n\t\t\treturn result;\n\t\t}\n\t}\n\tconst pact = new _Pact();\n\tconst reject = _settle.bind(null, pact, 2);\n\t(awaitBody ? result.then(_resumeAfterBody) : testValue.then(_resumeAfterTest)).then(void 0, reject);\n\treturn pact;\n\tfunction _resumeAfterTest(value) {\n\t\tfor (;;) {\n\t\t\tif (value === discriminant) {\n\t\t\t\tdispatchIndex = i;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tif (++i === cases.length) {\n\t\t\t\tif (dispatchIndex !== -1) {\n\t\t\t\t\tbreak;\n\t\t\t\t} else {\n\t\t\t\t\t_settle(pact, 1, result);\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t}\n\t\t\ttest = cases[i][0];\n\t\t\tif (test) {\n\t\t\t\tvalue = test();\n\t\t\t\tif (value && value.then) {\n\t\t\t\t\tvalue.then(_resumeAfterTest).then(void 0, reject);\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tdispatchIndex = i;\n\t\t\t}\n\t\t}\n\t\tdo {\n\t\t\tvar body = cases[dispatchIndex][1];\n\t\t\twhile (!body) {\n\t\t\t\tdispatchIndex++;\n\t\t\t\tbody = cases[dispatchIndex][1];\n\t\t\t}\n\t\t\tvar result = body();\n\t\t\tif (result && result.then) {\n\t\t\t\tresult.then(_resumeAfterBody).then(void 0, reject);\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tvar fallthroughCheck = cases[dispatchIndex][2];\n\t\t\tdispatchIndex++;\n\t\t} while (fallthroughCheck && !fallthroughCheck());\n\t\t_settle(pact, 1, result);\n\t}\n\tfunction _resumeAfterBody(result) {\n\t\tfor (;;) {\n\t\t\tvar fallthroughCheck = cases[dispatchIndex][2];\n\t\t\tif (!fallthroughCheck || fallthroughCheck()) {\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tdispatchIndex++;\n\t\t\tvar body = cases[dispatchIndex][1];\n\t\t\twhile (!body) {\n\t\t\t\tdispatchIndex++;\n\t\t\t\tbody = cases[dispatchIndex][1];\n\t\t\t}\n\t\t\tresult = body();\n\t\t\tif (result && result.then) {\n\t\t\t\tresult.then(_resumeAfterBody).then(void 0, reject);\n\t\t\t\treturn;\n\t\t\t}\n\t\t}\n\t\t_settle(pact, 1, result);\n\t}\n}\n\n// Asynchronously call a function and pass the result to explicitly passed continuations\nexport function _call(body, then, direct) {\n\tif (direct) {\n\t\treturn then ? then(body()) : body();\n\t}\n\ttry {\n\t\tvar result = Promise.resolve(body());\n\t\treturn then ? result.then(then) : result;\n\t} catch (e) {\n\t\treturn Promise.reject(e);\n\t}\n}\n\n// Asynchronously call a function and swallow the result\nexport function _callIgnored(body, direct) {\n\treturn _call(body, _empty, direct);\n}\n\n// Asynchronously call a function and pass the result to explicitly passed continuations\nexport function _invoke(body, then) {\n\tvar result = body();\n\tif (result && result.then) {\n\t\treturn result.then(then);\n\t}\n\treturn then(result);\n}\n\n// Asynchronously call a function and swallow the result\nexport function _invokeIgnored(body) {\n\tvar result = body();\n\tif (result && result.then) {\n\t\treturn result.then(_empty);\n\t}\n}\n\n// Asynchronously call a function and send errors to recovery continuation\nexport function _catch(body, recover) {\n\ttry {\n\t\tvar result = body();\n\t} catch(e) {\n\t\treturn recover(e);\n\t}\n\tif (result && result.then) {\n\t\treturn result.then(void 0, recover);\n\t}\n\treturn result;\n}\n\n// Asynchronously await a promise and pass the result to a finally continuation\nexport function _finallyRethrows(body, finalizer) {\n\ttry {\n\t\tvar result = body();\n\t} catch (e) {\n\t\treturn finalizer(true, e);\n\t}\n\tif (result && result.then) {\n\t\treturn result.then(finalizer.bind(null, false), finalizer.bind(null, true));\n\t}\n\treturn finalizer(false, result);\n}\n\n// Asynchronously await a promise and invoke a finally continuation that always overrides the result\nexport function _finally(body, finalizer) {\n\ttry {\n\t\tvar result = body();\n\t} catch (e) {\n\t\treturn finalizer();\n\t}\n\tif (result && result.then) {\n\t\treturn result.then(finalizer, finalizer);\n\t}\n\treturn finalizer();\n}\n\n// Rethrow or return a value from a finally continuation\nexport function _rethrow(thrown, value) {\n\tif (thrown)\n\t\tthrow value;\n\treturn value;\n}\n\n// Empty function to implement break and other control flow that ignores asynchronous results\nexport function _empty() {\n}\n\n// Sentinel value for early returns in generators \nexport const _earlyReturn = /*#__PURE__*/ {};\n\n// Asynchronously call a function and send errors to recovery continuation, skipping early returns\nexport function _catchInGenerator(body, recover) {\n\treturn _catch(body, function(e) {\n\t\tif (e === _earlyReturn) {\n\t\t\tthrow e;\n\t\t}\n\t\treturn recover(e);\n\t});\n}\n\n// Asynchronous generator class; accepts the entrypoint of the generator, to which it passes itself when the generator should start\nexport const _AsyncGenerator = /*#__PURE__*/(function() {\n\tfunction _AsyncGenerator(entry) {\n\t\tthis._entry = entry;\n\t\tthis._pact = null;\n\t\tthis._resolve = null;\n\t\tthis._return = null;\n\t\tthis._promise = null;\n\t}\n\n\tfunction _wrapReturnedValue(value) {\n\t\treturn { value: value, done: true };\n\t}\n\tfunction _wrapYieldedValue(value) {\n\t\treturn { value: value, done: false };\n\t}\n\n\t_AsyncGenerator.prototype._yield = function(value) {\n\t\t// Yield the value to the pending next call\n\t\tthis._resolve(value && value.then ? value.then(_wrapYieldedValue) : _wrapYieldedValue(value));\n\t\t// Return a pact for an upcoming next/return/throw call\n\t\treturn this._pact = new _Pact();\n\t};\n\t_AsyncGenerator.prototype.next = function(value) {\n\t\t// Advance the generator, starting it if it has yet to be started\n\t\tconst _this = this;\n\t\treturn _this._promise = new Promise(function (resolve) {\n\t\t\tconst _pact = _this._pact;\n\t\t\tif (_pact === null) {\n\t\t\t\tconst _entry = _this._entry;\n\t\t\t\tif (_entry === null) {\n\t\t\t\t\t// Generator is started, but not awaiting a yield expression\n\t\t\t\t\t// Abandon the next call!\n\t\t\t\t\treturn resolve(_this._promise);\n\t\t\t\t}\n\t\t\t\t// Start the generator\n\t\t\t\t_this._entry = null;\n\t\t\t\t_this._resolve = resolve;\n\t\t\t\tfunction returnValue(value) {\n\t\t\t\t\t_this._resolve(value && value.then ? value.then(_wrapReturnedValue) : _wrapReturnedValue(value));\n\t\t\t\t\t_this._pact = null;\n\t\t\t\t\t_this._resolve = null;\n\t\t\t\t}\n\t\t\t\tvar result = _entry(_this);\n\t\t\t\tif (result && result.then) {\n\t\t\t\t\tresult.then(returnValue, function(error) {\n\t\t\t\t\t\tif (error === _earlyReturn) {\n\t\t\t\t\t\t\treturnValue(_this._return);\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tconst pact = new _Pact();\n\t\t\t\t\t\t\t_this._resolve(pact);\n\t\t\t\t\t\t\t_this._pact = null;\n\t\t\t\t\t\t\t_this._resolve = null;\n\t\t\t\t\t\t\t_resolve(pact, 2, error);\n\t\t\t\t\t\t}\n\t\t\t\t\t});\n\t\t\t\t} else {\n\t\t\t\t\treturnValue(result);\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\t// Generator is started and a yield expression is pending, settle it\n\t\t\t\t_this._pact = null;\n\t\t\t\t_this._resolve = resolve;\n\t\t\t\t_settle(_pact, 1, value);\n\t\t\t}\n\t\t});\n\t};\n\t_AsyncGenerator.prototype.return = function(value) {\n\t\t// Early return from the generator if started, otherwise abandons the generator\n\t\tconst _this = this;\n\t\treturn _this._promise = new Promise(function (resolve) {\n\t\t\tconst _pact = _this._pact;\n\t\t\tif (_pact === null) {\n\t\t\t\tif (_this._entry === null) {\n\t\t\t\t\t// Generator is started, but not awaiting a yield expression\n\t\t\t\t\t// Abandon the return call!\n\t\t\t\t\treturn resolve(_this._promise);\n\t\t\t\t}\n\t\t\t\t// Generator is not started, abandon it and return the specified value\n\t\t\t\t_this._entry = null;\n\t\t\t\treturn resolve(value && value.then ? value.then(_wrapReturnedValue) : _wrapReturnedValue(value));\n\t\t\t}\n\t\t\t// Settle the yield expression with a rejected \"early return\" value\n\t\t\t_this._return = value;\n\t\t\t_this._resolve = resolve;\n\t\t\t_this._pact = null;\n\t\t\t_settle(_pact, 2, _earlyReturn);\n\t\t});\n\t};\n\t_AsyncGenerator.prototype.throw = function(error) {\n\t\t// Inject an exception into the pending yield expression\n\t\tconst _this = this;\n\t\treturn _this._promise = new Promise(function (resolve, reject) {\n\t\t\tconst _pact = _this._pact;\n\t\t\tif (_pact === null) {\n\t\t\t\tif (_this._entry === null) {\n\t\t\t\t\t// Generator is started, but not awaiting a yield expression\n\t\t\t\t\t// Abandon the throw call!\n\t\t\t\t\treturn resolve(_this._promise);\n\t\t\t\t}\n\t\t\t\t// Generator is not started, abandon it and return a rejected Promise containing the error\n\t\t\t\t_this._entry = null;\n\t\t\t\treturn reject(error);\n\t\t\t}\n\t\t\t// Settle the yield expression with the value as a rejection\n\t\t\t_this._resolve = resolve;\n\t\t\t_this._pact = null;\n\t\t\t_settle(_pact, 2, error);\n\t\t});\n\t};\n\n\t_AsyncGenerator.prototype[_asyncIteratorSymbol] = function() {\n\t\treturn this;\n\t};\n\t\n\treturn _AsyncGenerator;\n})();\n","import { Validator } from \"./form\";\n\n// yup type stubs\ninterface YupValidationError {\n    path?: string;\n    message?: string;\n    inner: YupValidationError[];\n}\ninterface YupValidationOptions {\n    strict?: boolean;\n    abortEarly?: boolean;\n    stripUnknown?: boolean;\n    recursive?: boolean;\n    context?: any;\n}\n\nexport function yupValidator<T, Error = string>(\n    yupSchema: any,\n    options?: YupValidationOptions,\n    messageTransformer?: (message: string) => Error\n): Validator<T, Error> {\n    return async (values: T) => {\n        try {\n            await yupSchema.validate(values, options);\n            return {};\n        } catch (ex) {\n            return yupErrorToErrorMap(ex, messageTransformer ?? ((e) => e as any));\n        }\n    };\n}\n\nexport function yupErrorToErrorMap<Error>(error: YupValidationError, errorTransformer: (message: string) => Error) {\n    let errors = error.path ? [error] : error.inner;\n    let obj = {};\n    for (let i = 0; i < errors.length; i++) {\n        let err = errors[i];\n        if (!err.path || !err.message) continue;\n        let pathSegments = Array.from(err.path.matchAll(/(\\w+)/gi)).map((e) => e[0]);\n        let o = obj;\n        for (let j = 0; j < pathSegments.length; j++) {\n            let key = pathSegments[j];\n            let oo = o[key];\n            if (!oo) {\n                oo = {};\n                o[key] = oo;\n            }\n            if (j === pathSegments.length - 1) {\n                o[key] = errorTransformer(err.message);\n            } else {\n                o = oo;\n            }\n        }\n    }\n    return obj;\n}\n","import React, { useEffect, useRef, useState } from \"react\";\nimport { ChildFormState, DirtyMap, ErrorMap, FormState } from \"./form\";\nimport { useArrayForm, useListener, useAnyListener, useChildForm } from \"./hooks\";\n\n/**\n * Wrapper around useArrayForm (which is a wrapper around useChildForm).\n * Exports useful functions to manipulate arrays.\n * This hook does cause a rerender, but only if the whole array changes.\n * @param parent The parent form.\n * @param name The parent's field to create a child form for.\n */\nexport function ArrayForm<Parent, ParentState, ParentError, Key extends keyof Parent>(props: {\n    form: FormState<Parent, ParentState, ParentError>;\n    name: Key;\n    render?: (props: {\n        form: ChildFormState<Parent, ParentState, ParentError, Key>;\n        remove: (index: number) => void;\n        clear: () => void;\n        move: (index: number, newIndex: number) => void;\n        swap: (index: number, newIndex: number) => void;\n        append: (value: NonNullable<Parent[Key]>[keyof NonNullable<Parent[Key]>]) => void;\n        values: NonNullable<Parent[Key]>;\n        setValues: (values: NonNullable<Parent[Key]>) => void;\n    }) => React.ReactNode;\n}) {\n    const childForm = useArrayForm(props.form, props.name);\n    const oldThruthly = useRef(!!props.form.values[props.name]);\n    const [, setRender] = useState(0);\n\n    // Rerender when array became null/not null (thruthly/falsely)\n    useEffect(() => {\n        let id = props.form.listen(props.name, () => {\n            let thruthly = !!props.form.values[props.name];\n            if (thruthly !== oldThruthly.current) {\n                setRender((i) => i + 1);\n                oldThruthly.current = thruthly;\n            }\n        });\n        return () => props.form.ignore(props.name, id);\n    }, []);\n\n    // Do not render anything if the parent field is falsly\n    if (!props.form.values[props.name]) return null;\n    return <React.Fragment>{props.render?.(childForm) ?? childForm.values + \"\"}</React.Fragment>;\n}\n\n/**\n * Wrapper around useListener\n * Listen for changes on a form's field. Behaves like useState.\n * You shouldn't use this hook in large components, as it rerenders each time something changes. Use the wrapper <Listener /> instead.\n * @param form The form to listen on.\n * @param name The form's field to listen to.\n */\nexport function Listener<T, State, Error, Key extends keyof T>(props: {\n    form: FormState<T, State, Error>;\n    name: Key;\n    render?: (props: {\n        value: T[Key];\n        defaultValue: T[Key];\n        setValue: (value: T[Key]) => void;\n        dirty: DirtyMap<T>[Key];\n        error: ErrorMap<T, Error>[Key];\n        state: State;\n        form: FormState<T, State, Error>;\n    }) => React.ReactNode;\n}) {\n    const l = useListener(props.form, props.name);\n    return <React.Fragment>{props.render?.(l) ?? l.value + \"\"}</React.Fragment>;\n}\n\n/**\n * Wrapper around useAnyListener.\n * Listens for any change on this form. Behaves like useState.\n * You shouldn't use this hook in large components, as it rerenders each time something changes. Use the wrapper <AnyListener /> instead.\n * @param form The form to listen to.\n */\nexport function AnyListener<T, State, Error>(props: {\n    form: FormState<T, State, Error>;\n    render?: (props: FormState<T, State, Error>) => React.ReactNode;\n}) {\n    const l = useAnyListener(props.form);\n    return <React.Fragment>{props.render?.(l) ?? l.values + \"\"}</React.Fragment>;\n}\n\n/**\n * Wrapper around useChildForm\n * Creates a child form for another root or child form. You must use this for object and array (see useArrayForm) fields.\n * This hook doesn't cause a rerender.\n * @param parentForm The parent form.\n * @param name The parent's field to create a child form for.\n */\nexport function ChildForm<Parent, ParentState, ParentError, Key extends keyof Parent>(props: {\n    form: FormState<Parent, ParentState, ParentError>; // Use the parent prop instead of the form prop when using ChildForm.\n    name: Key;\n    render?: (props: ChildFormState<Parent, ParentState, ParentError, Key>) => React.ReactNode;\n}) {\n    const childForm = useChildForm(props.form, props.name);\n    const oldThruthly = useRef(!!props.form.values[props.name]);\n    const [, setRender] = useState(0);\n\n    // Only rerender when object became null/not null (thruthly/falsely)\n    useEffect(() => {\n        let id = props.form.listen(props.name, () => {\n            let thruthly = !!props.form.values[props.name];\n            if (thruthly !== oldThruthly.current) {\n                setRender((i) => i + 1);\n                oldThruthly.current = thruthly;\n            }\n        });\n        return () => props.form.ignore(props.name, id);\n    }, []);\n\n    // Do not render anything if the parent field is falsly\n    if (!props.form.values[props.name]) return null;\n    return <React.Fragment>{props.render?.(childForm)}</React.Fragment>;\n}\n","import React, { HTMLAttributes } from \"react\";\nimport { FormState } from \"../form\";\nimport { useListener } from \"../hooks\";\n\nexport type FormErrorProps<T, Error, Key extends keyof T> = Omit<HTMLAttributes<HTMLParagraphElement>, \"name\" | \"form\"> & {\n    form: FormState<T, any, Error>;\n    name: Key;\n};\n\nexport function FormError<T, Error, Key extends keyof T>({ form, name, ...rest }: FormErrorProps<T, Error, Key>) {\n    const { error } = useListener(form, name);\n    if (!error || typeof error === \"object\") return null;\n    return <p {...rest}>{error + \"\"}</p>;\n}\n","import React, { SelectHTMLAttributes } from \"react\";\nimport { DefaultState, FormState } from \"../form\";\nimport { DEFAULT_DIRTY_CLASS, DEFAULT_ERROR_CLASS, getClassName } from \"./FormInput\";\nimport { useListener } from \"../hooks\";\n\nexport type FormSelectProps<T, State, Error> = Omit<SelectHTMLAttributes<HTMLSelectElement>, \"form\" | \"name\"> & {\n    form: FormState<T, State, Error>;\n    name: keyof T;\n    errorClassName?: string;\n    errorStyle?: React.CSSProperties;\n    dirtyClassName?: string;\n    dirtyStyle?: React.CSSProperties;\n    disableOnSubmitting?: boolean;\n    hideWhenNull?: boolean;\n};\n\nexport function FormSelect<T, State extends DefaultState, Error>({\n    form,\n    name,\n    errorClassName,\n    errorStyle,\n    dirtyClassName,\n    dirtyStyle,\n    disableOnSubmitting,\n    hideWhenNull,\n    children,\n    className,\n    style,\n    ...rest\n}: FormSelectProps<T, State, Error>) {\n    const { value, setValue, state, dirty, error } = useListener(form, name);\n    if (hideWhenNull && (value === null || value === undefined)) return null;\n    return (\n        <select\n            style={{\n                ...style,\n                ...(dirty && dirtyStyle),\n                ...(error && errorStyle)\n            }}\n            className={getClassName(className, dirty && (dirtyClassName ?? DEFAULT_DIRTY_CLASS), error && (errorClassName ?? DEFAULT_ERROR_CLASS))}\n            disabled={(disableOnSubmitting ?? true) && state.isSubmitting}\n            value={value as any}\n            onChange={(ev) => {\n                if (rest.multiple) setValue(Array.from(ev.target.selectedOptions).map((e) => e.value) as any);\n                else setValue(ev.target.value as any);\n            }}\n            {...rest}\n        >\n            {children}\n        </select>\n    );\n}\n","import React, { TextareaHTMLAttributes } from \"react\";\nimport { DefaultState, FormState } from \"../form\";\nimport { DEFAULT_DIRTY_CLASS, DEFAULT_ERROR_CLASS, getClassName } from \"./FormInput\";\nimport { useListener } from \"../hooks\";\n\nexport type FormTextAreaProps<T, State, Error> = Omit<TextareaHTMLAttributes<HTMLTextAreaElement>, \"form\" | \"name\"> & {\n    form: FormState<T, State, Error>;\n    name: keyof T;\n    errorClassName?: string;\n    errorStyle?: React.CSSProperties;\n    dirtyClassName?: string;\n    dirtyStyle?: React.CSSProperties;\n    disableOnSubmitting?: boolean;\n    hideWhenNull?: boolean;\n};\n\nexport function FormTextArea<T, State extends DefaultState, Error>({\n    form,\n    name,\n    errorClassName,\n    errorStyle,\n    dirtyClassName,\n    dirtyStyle,\n    disableOnSubmitting,\n    children,\n    className,\n    hideWhenNull,\n    style,\n    ...rest\n}: FormTextAreaProps<T, State, Error>) {\n    const { value, setValue, state, dirty, error } = useListener(form, name);\n    if (hideWhenNull && (value === null || value === undefined)) return null;\n    return (\n        <textarea\n            style={{\n                ...style,\n                ...(dirty && dirtyStyle),\n                ...(error && errorStyle)\n            }}\n            className={getClassName(className, dirty && (dirtyClassName ?? DEFAULT_DIRTY_CLASS), error && (errorClassName ?? DEFAULT_ERROR_CLASS))}\n            disabled={(disableOnSubmitting ?? true) && state.isSubmitting}\n            value={value as any}\n            onChange={(ev) => setValue(ev.target.value as any)}\n            {...rest}\n        >\n            {children}\n        </textarea>\n    );\n}\n","import React, { useRef } from \"react\";\n\nexport function VisualRender(props: { children: React.ReactNode }) {\n    let ref = useRef<HTMLDivElement>(null);\n    let timeoutRef = useRef<number | null>(null);\n\n    if (ref.current) {\n        ref.current.className = \"\";\n        if (timeoutRef.current) clearTimeout(timeoutRef.current);\n        timeoutRef.current = window.setTimeout(() => {\n            ref.current && (ref.current.className = \"blink\");\n        }, 100);\n    }\n\n    return (\n        <div className=\"blink\" ref={ref}>\n            {props.children}\n        </div>\n    );\n}\n","import React, { useState } from \"react\";\nimport {\n    AnyListener,\n    ArrayForm,\n    FormError,\n    FormState,\n    FormInput,\n    FormSelect,\n    useAnyListener,\n    useChildForm,\n    useForm,\n    Listener,\n    FormTextArea,\n    ChildForm,\n    yupValidator\n} from \"typed-react-form\";\nimport { VisualRender } from \"./VisualRender\";\nimport * as yup from \"yup\";\n\ninterface ExampleFormData {\n    id: number;\n    name: string;\n    description: string;\n    author: User | null;\n    public: boolean;\n    date: number;\n    dateObject: Date;\n    language: \"en\" | \"nl\" | \"fr\";\n    tags: string[];\n    todos: Todo[];\n}\n\ninterface Todo {\n    message: string;\n    priority: \"low\" | \"normal\" | \"high\";\n}\n\ninterface User {\n    name: string;\n    age: number;\n}\n\nexport default function App() {\n    return (\n        <div>\n            <div style={{ padding: \"2em\", background: \"#333\", color: \"white\" }}>\n                <h1>\n                    Example form created using{\" \"}\n                    <a style={{ color: \"#3793ee\" }} href=\"https://github.com/CodeStix/typed-react-form\">\n                        typed-react-form\n                    </a>\n                </h1>\n                <p>\n                    The <strong style={{ color: \"red\" }}>red flash</strong> indicates which parts of the form are being rerendered. The{\" \"}\n                    <strong style={{ outline: \"3px solid gray\" }}>gray outline</strong> indicates that a field is dirty (modified) and the{\" \"}\n                    <strong style={{ outline: \"3px solid red\" }}>red outline</strong> indicates an error.\n                </p>\n                <p>\n                    Every part of this form's{\" \"}\n                    <a style={{ color: \"#3793ee\" }} href=\"https://github.com/CodeStix/typed-react-form/blob/master/example/src/App.tsx\">\n                        source code\n                    </a>{\" \"}\n                    is type-checked.\n                </p>\n            </div>\n            <Form />\n        </div>\n    );\n}\n\nconst initialValues: ExampleFormData = {\n    id: Math.ceil(Math.random() * 100000),\n    name: \"My todo list\",\n    description: \"this is a testing form\",\n    author: null,\n    public: true,\n    date: new Date(\"1990-01-12T00:00:00.000Z\").getTime(),\n    dateObject: new Date(\"1990-01-12T00:00:00.000Z\"),\n    tags: [\"test\"],\n    language: \"en\",\n    todos: [{ message: \"This is a todo\", priority: \"normal\" }]\n};\n\nconst TodoListSchema = yup.object({\n    name: yup.string().required(\"Enter a name\").min(5, \"Enter a longer name\")\n});\n\nexport function Form() {\n    const form = useForm(\n        initialValues, // <- Default values, may change\n        yupValidator(TodoListSchema), // <- Validator (optional)\n        false, // <- Validate on change (optional)\n        false // <- Validate on mount (optional)\n    );\n\n    return (\n        <form\n            onSubmit={async (ev) => {\n                ev.preventDefault();\n\n                await form.validate(); // Validate manually when validateOnChange is disabled.\n                if (form.error) return; // Do not submit if errors\n\n                form.setState({ isSubmitting: true }); // Set the form state (updates every component listening for state updates)\n\n                await new Promise((res) => setTimeout(res, 1000)); // Fake fetch\n\n                form.setState({ isSubmitting: false }); // Set the form state (updates every component listening for state updates)\n                form.setDefaultValues(form.values); // Set new default values\n            }}\n        >\n            <div style={{ display: \"grid\", gridTemplateColumns: \"60% 40%\", gridTemplateRows: \"100%\", gap: \"2em\", margin: \"2em\" }}>\n                <VisualRender>\n                    <h3>\n                        Id <small>number</small>\n                    </h3>\n                    <FormInput type=\"number\" form={form} name=\"id\" />\n                    <hr />\n                    <h3>\n                        Name <small>string</small>\n                    </h3>\n                    <FormInput form={form} name=\"name\" />\n                    <FormError form={form} name=\"name\" />\n                    <hr />\n                    <h3>\n                        Public? <small>boolean</small>\n                    </h3>\n                    <p>Using radio buttons</p>\n                    <label>\n                        <FormInput type=\"radio\" form={form} name=\"public\" value={false} /> no\n                    </label>\n                    <label>\n                        <FormInput type=\"radio\" form={form} name=\"public\" value={true} /> yes\n                    </label>\n                    <p>Using checkbox</p>\n                    <label>\n                        <FormInput type=\"checkbox\" form={form} name=\"public\" /> yes/no\n                    </label>\n                    <hr />\n                    <h3>\n                        Language <small>enum</small>\n                    </h3>\n                    <p>Using select</p>\n                    <FormSelect form={form} name=\"language\">\n                        <option value=\"en\">English</option>\n                        <option value=\"nl\">Dutch</option>\n                        <option value=\"fr\">French</option>\n                    </FormSelect>\n                    <p>Using radio buttons</p>\n                    <label>\n                        <FormInput type=\"radio\" form={form} name=\"language\" value=\"en\" /> English\n                    </label>\n                    <label>\n                        <FormInput type=\"radio\" form={form} name=\"language\" value=\"nl\" /> Dutch\n                    </label>\n                    <label>\n                        <FormInput type=\"radio\" form={form} name=\"language\" value=\"fr\" /> French\n                    </label>\n                    <hr />\n                    <h3>\n                        Todo's <small>dynamic array</small>\n                    </h3>\n                    {/* Use ArrayForm (wrapper around useArrayForm) to create dynamic forms */}\n                    <FormError form={form} name=\"todos\" />\n                    <ArrayForm\n                        form={form}\n                        name=\"todos\"\n                        render={(\n                            { form, swap, remove, append, values, setValues } // <- Make sure to use the newly passed form (otherwise type checking will not work!)\n                        ) => (\n                            <VisualRender>\n                                <ul>\n                                    {form.values.map((\n                                        _,\n                                        i // You should use other key than index\n                                    ) => (\n                                        <TodoItem onMoveTop={() => swap(i, 0)} onRemove={() => remove(i)} key={i} parent={form} index={i} />\n                                    ))}\n                                </ul>\n                                <button\n                                    type=\"button\"\n                                    onClick={() => {\n                                        append({\n                                            message: \"\",\n                                            priority: \"normal\"\n                                        });\n                                    }}\n                                >\n                                    Add item\n                                </button>\n                                <button\n                                    type=\"button\"\n                                    onClick={() => {\n                                        setValues([\n                                            ...values,\n                                            ...Array(50)\n                                                .fill(0)\n                                                .map((_, i) => ({\n                                                    message: \"Fix this \" + i,\n                                                    priority: \"normal\" as \"normal\" // Wut\n                                                }))\n                                        ]);\n                                    }}\n                                >\n                                    Add 50 items\n                                </button>\n                            </VisualRender>\n                        )}\n                    />\n                    <button type=\"button\" onClick={() => form.setError(\"todos\", \"There is something wrong with the array\")}>\n                        Set array error\n                    </button>\n                    <hr />\n                    <h3>\n                        Date <small>timestamp number</small>\n                    </h3>\n                    <FormInput type=\"date\" form={form} name=\"date\" dateAsNumber />\n                    <hr />\n                    <h3>\n                        Date <small>date object</small>\n                    </h3>\n                    <FormInput type=\"date\" form={form} name=\"dateObject\" />\n                    <Listener\n                        form={form}\n                        name=\"dateObject\"\n                        render={({ value }) => <p>Your age is {new Date().getFullYear() - value.getFullYear()}</p>}\n                    />\n                    <hr />\n                    <h3>\n                        Tags <small>string array</small>\n                    </h3>\n                    <p>\n                        Using select with <code>multiple=true</code>\n                    </p>\n                    <FormSelect form={form} name=\"tags\" multiple>\n                        <option value=\"test\">Test</option>\n                        <option value=\"fun\">Fun</option>\n                        <option value=\"school\">School</option>\n                    </FormSelect>\n                    <p>Using checkboxes</p>\n                    <label>\n                        <FormInput form={form} name=\"tags\" type=\"checkbox\" value=\"test\" />\n                        Test\n                    </label>\n                    <label>\n                        <FormInput form={form} name=\"tags\" type=\"checkbox\" value=\"fun\" />\n                        Fun\n                    </label>\n                    <label>\n                        <FormInput form={form} name=\"tags\" type=\"checkbox\" value=\"school\" />\n                        School\n                    </label>\n                    <hr />\n                    <h3>Togglable object field</h3>\n                    <label>\n                        <FormInput form={form} name=\"author\" type=\"checkbox\" setNullOnUncheck value={{ name: \"\", age: 0 }} />\n                        Enable author\n                    </label>\n                    <ChildForm\n                        form={form}\n                        name=\"author\"\n                        render={(form) => (\n                            <VisualRender>\n                                <div style={{ background: \"#0001\", padding: \"1em\" }}>\n                                    <p>Name</p>\n                                    <FormInput form={form} name=\"name\" />\n                                    <p>Age</p>\n                                    <FormInput form={form} name=\"age\" type=\"number\" />\n                                </div>\n                            </VisualRender>\n                        )}\n                    />\n                    <hr />\n                    <h3>\n                        Description <small>string</small>\n                    </h3>\n                    <p>\n                        Using <code>FormTextArea</code>\n                    </p>\n                    <FormTextArea form={form} name=\"description\" rows={5} cols={50} />\n                    <p>\n                        Using <code>Listener</code> around <code>textarea</code>\n                    </p>\n                    <Listener\n                        form={form}\n                        name=\"description\"\n                        render={({ value, setValue }) => (\n                            <textarea rows={5} cols={50} value={value} onChange={(ev) => setValue(ev.target.value)}></textarea>\n                        )}\n                    />\n                </VisualRender>\n                <div style={{ position: \"sticky\", top: \"0\", height: \"500px\" }}>\n                    <h2>Output</h2>\n                    <FormValues form={form} />\n\n                    {/* Disable buttons when form is submitting or when nothing has changed, the AnyListener wrapper is required */}\n                    <AnyListener\n                        form={form}\n                        render={({ state, dirty }) => (\n                            <div style={{ margin: \"0.5em 0\" }}>\n                                <button style={{ fontSize: \"1.3em\" }} disabled={state.isSubmitting || !dirty}>\n                                    Submit\n                                </button>\n                                <button\n                                    style={{ fontSize: \"1.3em\" }}\n                                    disabled={state.isSubmitting || !dirty}\n                                    type=\"button\"\n                                    onClick={() => form.resetAll()}\n                                >\n                                    Reset\n                                </button>\n                            </div>\n                        )}\n                    />\n\n                    <div>\n                        <button style={{ fontSize: \"1.3em\" }} type=\"button\" onClick={() => form.validate()}>\n                            Validate\n                        </button>\n                        <label>\n                            <code>validateOnChange</code>\n                            <input\n                                type=\"checkbox\"\n                                defaultChecked={form.validateOnChange}\n                                onChange={(e) => (form.validateOnChange = e.target.checked)}\n                            />\n                        </label>\n                    </div>\n                </div>\n            </div>\n        </form>\n    );\n}\n\nfunction TodoItem(props: { parent: FormState<Todo[]>; index: number; onMoveTop: () => void; onRemove: () => void }) {\n    // Use a child form, each layer in the object is a seperate form: TodoList (useForm) -> Todo[] (useArrayForm) -> Todo (useChildForm)\n    const form = useChildForm(props.parent, props.index);\n\n    return (\n        <li\n            style={{\n                padding: \"0.5em\"\n            }}\n        >\n            <VisualRender>\n                <FormInput form={form} name=\"message\" />\n                <FormSelect form={form} name=\"priority\">\n                    <option value=\"low\">Low</option>\n                    <option value=\"normal\">Normal</option>\n                    <option value=\"high\">High</option>\n                </FormSelect>\n                <button type=\"button\" onClick={props.onMoveTop}>\n                    Go to top\n                </button>\n                <button type=\"button\" onClick={props.onRemove}>\n                    Remove\n                </button>\n            </VisualRender>\n        </li>\n    );\n}\n\n/**\n *  Shows a JSON representation of a form\n */\nfunction FormValues<T>(props: { form: FormState<T> }) {\n    const form = useAnyListener(props.form);\n    const [show, setShow] = useState({ values: true, defaultValues: false, errorMap: true, dirtyMap: true, state: false });\n    return (\n        <VisualRender>\n            <div style={{ background: \"#0001\", overflow: \"hidden\", padding: \"1em\", borderRadius: \"1em\" }}>\n                <p>\n                    <strong style={{ color: form.dirty ? \"blue\" : undefined }}>{form.dirty ? \"Modified\" : \"Unmodified\"}</strong>\n                </p>\n                <p>\n                    <strong style={{ color: form.error ? \"red\" : undefined }}>{form.error ? \"Has error\" : \"No errors\"}</strong>\n                </p>\n\n                <div>\n                    <strong>Show: </strong>\n                    <label>\n                        <input type=\"checkbox\" checked={show.values} onChange={(ev) => setShow({ ...show, values: ev.target.checked })} />\n                        <code>values</code>\n                    </label>\n                    <label>\n                        <input\n                            type=\"checkbox\"\n                            checked={show.defaultValues}\n                            onChange={(ev) => setShow({ ...show, defaultValues: ev.target.checked })}\n                        />\n                        <code>defaultValues</code>\n                    </label>\n                    <label>\n                        <input type=\"checkbox\" checked={show.errorMap} onChange={(ev) => setShow({ ...show, errorMap: ev.target.checked })} />\n                        <code>errorMap</code>\n                    </label>\n                    <label>\n                        <input type=\"checkbox\" checked={show.dirtyMap} onChange={(ev) => setShow({ ...show, dirtyMap: ev.target.checked })} />\n                        <code>dirtyMap</code>\n                    </label>\n                    <label>\n                        <input type=\"checkbox\" checked={show.state} onChange={(ev) => setShow({ ...show, state: ev.target.checked })} />\n                        <code>state</code>\n                    </label>\n                </div>\n\n                {show.values && <pre>values = {JSON.stringify(form.values, null, 2)}</pre>}\n                {show.defaultValues && <pre>defaultValues = {JSON.stringify(form.defaultValues, null, 2)}</pre>}\n                {show.errorMap && <pre>errorMap = {JSON.stringify(form.errorMap, null, 2)}</pre>}\n                {show.dirtyMap && <pre>dirtyMap = {JSON.stringify(form.dirtyMap, null, 2)}</pre>}\n                {show.state && <pre>state = {JSON.stringify(form.state, null, 2)}</pre>}\n            </div>\n        </VisualRender>\n    );\n}\n\n// You should use a validation library (yup, class-validator) instead of this mess...\n// function validateTodoList(values: ExampleFormData) {\n//     let todoErrors = values.todos.reduce((prev, val, index) => {\n//         if (val.message.length < 5) {\n//             prev[index] = { message: \"Todo message should be longer!\" };\n//         }\n//         return prev;\n//     }, [] as any[]);\n//     return {\n//         // author: values.author.length < 3 ? \"Author name is too short.\" : undefined,\n//         name: values.name.length < 3 ? \"Title is too short.\" : undefined,\n//         todos: todoErrors.length > 0 ? todoErrors : undefined\n//     };\n// }\n","import \"./index.css\";\n\nimport React from \"react\";\nimport ReactDOM from \"react-dom\";\nimport App from \"./App\";\n\nReactDOM.render(<App />, document.getElementById(\"root\"));\n"],"sourceRoot":""}