{"version":3,"sources":["../../src/form.ts","../../src/hooks.ts","../../src/elements/FormInput.tsx","../../node_modules/babel-plugin-transform-async-to-promises/helpers.js","../../src/yup.ts","../../src/Components.tsx","../../src/elements/FormError.tsx","../../src/elements/FormSelect.tsx","../../src/elements/FormTextArea.tsx","VisualRender.tsx","App.tsx","index.tsx"],"names":["memberCopy","value","Array","Error","comparePrimitiveObject","a","b","ak","Object","bk","lk","i","k","av","bv","FormState","validateOnChange","formId","childMap","dirtyMap","errorMap","listeners","anyListeners","counter","this","setValueInternal","validate","isDefault","notifyChild","notifyParent","fireAny","valueMap","child","updateParentValues","setValue","dirty","values","defaultValues","console","key","setValues","newKeys","localKeys","mostKeys","setDefaultValues","setErrors","e","setError","error","updateParentErrors","errors","resetAll","reset","setState","c","updateParentState","listen","setters","id","listenAny","ignore","ignoreAny","fireListeners","l","fireAnyListeners","al","ChildFormState","parent","useChildForm","parentForm","name","useRef","useEffect","useListener","form","onlyOnSetValues","setRender","useState","defaultValue","state","useAnyListener","useArrayForm","remove","newValues","move","to","newArr","target","increment","swap","index","newIndex","clear","append","getClassName","args","Symbol","iterator","asyncIterator","yupErrorToErrorMap","errorTransformer","obj","err","pathSegments","o","j","oo","props","React","arr","childForm","FormError","rest","FormInput","style","className","disableOnSubmitting","dateAsNumber","errorClassName","errorStyle","dirtyClassName","dirtyStyle","setUndefinedOnUncheck","setNullOnUncheck","hideWhenNull","inputValue","currentValue","useMemo","inValue","inChecked","n","ni","parseInt","isNaN","d","Date","disabled","checked","onChange","newValue","ev","newChecked","parseFloat","FormSelect","children","FormTextArea","defaultState","validator","isSubmitting","yupSchema","options","messageTransformer","body","recover","result","then","ex","VisualRender","ref","timeoutRef","current","clearTimeout","window","setTimeout","App","padding","background","color","href","outline","Form","initialValues","Math","ceil","random","description","author","public","date","getTime","dateObject","tags","language","todos","message","priority","useForm","validateTodoList","onSubmit","preventDefault","Promise","res","display","gridTemplateColumns","gridTemplateRows","gap","margin","type","render","map","_","TodoItem","onMoveTop","onRemove","onClick","multiple","rows","cols","age","position","top","height","FormValues","fontSize","defaultChecked","show","setShow","overflow","borderRadius","undefined","JSON","stringify","todoErrors","reduce","prev","val","length","ReactDOM","document","getElementById"],"mappings":"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","file":"static/js/main.96d32858.chunk.js","sourcesContent":["export type ListenerCallback = (setValuesWasUsed: boolean) => void;\nexport type ListenerMap = { [T in string]?: ListenerCallback };\nexport type Validator<T, Error> = (values: T) => ErrorMap<T, Error> | Promise<ErrorMap<T, Error>>;\n\nexport type ChildFormMap<T, State, Error> = {\n    [Key in keyof T]?: ChildFormState<T, State, Error, Key>;\n};\n\nexport type DirtyMap<T> = {\n    [Key in keyof T]?: boolean;\n};\n\ntype ObjectOrArray = {\n    [key: string]: any;\n    [key: number]: any;\n};\n\nexport type ErrorType<T, Error> = T extends ObjectOrArray ? ErrorMap<T, Error> : Error;\n\nexport type ErrorMap<T, Error> = {\n    [Key in keyof T]?: ErrorType<T[Key], Error>;\n};\n\nexport type DefaultError = string;\nexport type DefaultState = { isSubmitting: boolean };\n\nexport function memberCopy<T>(value: T): T {\n    if (Array.isArray(value)) {\n        return [...value] as any;\n    } else if (typeof value === \"object\") {\n        return { ...value };\n    } else {\n        throw new Error(\"Can only memberCopy() arrays and objects.\");\n    }\n}\n\n/**\n * Compares 2 objects that only contain primitive fields (no object fields)\n * @returns true when different, false when 'equal', undefined when an object field was found.\n */\nexport function comparePrimitiveObject<T>(a: T, b: T): boolean | undefined {\n    // Compare null and undefined\n    if (!a || !b) return a === b;\n    let ak = Object.keys(a),\n        bk = Object.keys(b);\n    let lk = ak.length > bk.length ? ak : bk;\n    for (let i = 0; i < lk.length; i++) {\n        let k = lk[i];\n        let av = a[k],\n            bv = b[k];\n        if ((typeof av === \"object\" && av !== null) || (typeof bv === \"object\" && bv !== null)) return undefined;\n        if (av !== bv) return true;\n    }\n    return false;\n}\n\nexport class FormState<T, State = DefaultState, Error = DefaultError> {\n    /**\n     * The id of this form, for debugging purposes.\n     */\n    public readonly formId = ++FormState.formCounter;\n\n    /**\n     * The form's validator.\n     */\n    public validator?: Validator<T, Error>;\n\n    /**\n     * Should the form validate on each value change?\n     */\n    public validateOnChange: boolean;\n\n    /**\n     * The values on this form. Use setValues() to set these.\n     */\n    public readonly values: T;\n\n    /**\n     * The default values on this form. Use setDefaultValues(...) to set these.\n     */\n    public readonly defaultValues: T;\n\n    /**\n     * The dictionary that maps object fields to child forms.\n     */\n    public readonly childMap: ChildFormMap<T, State, Error> = {};\n\n    /**\n     * The dictionary that contains dirty states for each field.\n     */\n    public readonly dirtyMap: DirtyMap<T> = {};\n\n    /**\n     * The dictionary that contains errors for each field.\n     */\n    public readonly errorMap: ErrorMap<T, Error> = {};\n\n    private _state: State;\n    private listeners: { [Key in keyof T]?: ListenerMap } = {};\n    private anyListeners: ListenerMap = {};\n    private counter = 0;\n    private static formCounter = 0;\n\n    public constructor(values: T, defaultValues: T, defaultState: State, validator?: Validator<T, Error>, validateOnChange = true) {\n        this.values = memberCopy(values);\n        this.defaultValues = memberCopy(defaultValues);\n        this._state = memberCopy(defaultState);\n        this.validator = validator;\n        this.validateOnChange = validateOnChange;\n    }\n\n    /**\n     * Gets the state of the current form.\n     */\n    public get state() {\n        return this._state;\n    }\n\n    /**\n     * Is this form modified?\n     */\n    public get dirty() {\n        return Object.keys(this.dirtyMap).some((e) => this.dirtyMap[e]);\n    }\n\n    /**\n     * Does this form contain any error?\n     */\n    public get error() {\n        return Object.keys(this.errorMap).some((e) => this.errorMap[e]);\n    }\n\n    /**\n     * Is this form null/undefined or {}?\n     */\n    public get empty() {\n        return Object.keys(this.values).length === 0;\n    }\n\n    /**\n     * Sets a value the advanced way.\n     * @param key The field to set.\n     * @param value The value to set in the field.\n     * @param dirty Is this field dirty? Leave undefined to not set any dirty value. (can always be overridden by child forms)\n     * @param validate Should the form validate after value set? This does not override `validateOnChange`.\n     * @param isDefault Is this the default value for the said field?\n     * @param notifyChild Should this form notify any child form about the change?\n     * @param notifyParent Should this form notify any parent form about the change?\n     * @param fireAny Fire all `anyListeners` after field is set? You should not touch this. (will be false for bulk sets, they will call fireAnyListeners() after every field is set)\n     */\n    public setValueInternal<Key extends keyof T>(\n        key: Key,\n        value: T[Key] | undefined,\n        dirty: boolean,\n        validate: boolean = true,\n        isDefault: boolean = false,\n        notifyChild: boolean = true,\n        notifyParent: boolean = true,\n        fireAny: boolean = true\n    ) {\n        let valueMap = isDefault ? this.defaultValues : this.values;\n        if (value === undefined) {\n            if (Array.isArray(valueMap)) valueMap.splice(key as number, 1);\n            else delete valueMap[key];\n        } else {\n            valueMap[key] = value;\n        }\n\n        this.dirtyMap[key] = dirty;\n\n        if (notifyChild) {\n            let child = this.childMap[key];\n            if (child) {\n                child.setValues(value ?? ({} as any), true, isDefault, true, false);\n                this.dirtyMap[key] = child.dirty;\n            }\n        }\n\n        this.fireListeners(key, false);\n        if (fireAny) {\n            // Will be false when using setValues, he will call fireAnyListeners and notifyParentValues itself\n            if (notifyParent) this.updateParentValues(isDefault); // Will call setValueInternal on parent\n            this.fireAnyListeners(false);\n        }\n\n        if (validate && this.validateOnChange && this.validator) this.validate();\n    }\n\n    /**\n     * Set a value on this form.\n     * @param key The field to set.\n     * @param value The field's new value.\n     * @param validate Should the form validate?\n     * @param isDefault Is this the default value?\n     * @param notifyChild Should this form notify the child form about this change?\n     * @param notifyParent Should this form notify the parent form about this change?\n     * @param fireAny Fire all `anyListeners` after field is set? You should not touch this. (will be false for bulk sets, they will call fireAnyListeners() after every field is set)\n     */\n    public setValue<Key extends keyof T>(\n        key: Key,\n        value: T[Key] | undefined,\n        validate: boolean = true,\n        isDefault: boolean = false,\n        notifyChild: boolean = true,\n        notifyParent: boolean = true,\n        fireAny: boolean = true\n    ) {\n        if (typeof value === \"object\") {\n            // Do not compare objects, child form of this object field should mark dirty on its parent form (= this form)\n            let dirty: boolean | undefined = false;\n            if (fireAny) {\n                // Compare value against defaultValues when !isDefault else compare against values (is not switched!!)\n                if (value instanceof Date) {\n                    dirty = value?.getTime() !== (isDefault ? this.values[key] : (this.defaultValues[key] as any))?.getTime();\n                } else {\n                    dirty = comparePrimitiveObject(value, isDefault ? this.values[key] : this.defaultValues[key]);\n                    if (dirty === undefined) {\n                        console.warn(\"Do not use setValue for object in object fields, use setValueInternal instead (dirty value can not be determined), \", key, value);\n                        dirty = true;\n                    }\n                }\n            }\n            this.setValueInternal(key, value, dirty, validate, isDefault, notifyChild, notifyParent, fireAny);\n        } else {\n            // Calculate and compare value types, determine dirty?\n            if ((isDefault && this.defaultValues[key] === value) || (!isDefault && this.values[key] === value)) return false;\n            this.setValueInternal(key, value, isDefault ? value !== this.values[key] : value !== this.defaultValues[key], validate, isDefault, notifyChild, notifyParent, fireAny);\n        }\n        return true;\n    }\n\n    /**\n     * Set all values on this form.\n     * @param values The new values to set on this form.\n     * @param validate Validate? Does not override `validateOnChange`.\n     * @param isDefault Are these values the default values for this form?\n     * @param notifyChild Should this form notify the child form about this change?\n     * @param notifyParent Should this form notify the parent form about this change?\n     */\n    public setValues(values: T, validate: boolean = true, isDefault: boolean = false, notifyChild: boolean = true, notifyParent: boolean = true) {\n        // Copy the values to the local form object\n        let newKeys = Object.keys(isDefault ? this.defaultValues : this.values);\n        let localKeys = Object.keys(values);\n        let mostKeys = newKeys.length > localKeys.length ? newKeys : localKeys;\n        for (let i = 0; i < mostKeys.length; i++) {\n            let key = mostKeys[i] as keyof T;\n            this.setValue(\n                key,\n                values[key],\n                false, // Will validate after all values are copied\n                isDefault,\n                notifyChild,\n                notifyParent,\n                false // Will call fireAnyListener after all values are copied, see 3 lines down\n            );\n        }\n        if (notifyParent) this.updateParentValues(isDefault);\n        this.fireAnyListeners(true);\n\n        if (validate && this.validateOnChange && this.validator) this.validate();\n    }\n\n    /**\n     * Set default values for this form. (Convenience wrapper around `setValues()`)\n     * @param values The new default values to set on this form.\n     * @param validate Validate?\n     * @param notifyChild Should this form notify the child form about this change?\n     * @param notifyParent Should this form notify the parent form about this change?\n     */\n    public setDefaultValues(values: T, validate: boolean = true, notifyChild: boolean = true, notifyParent: boolean = true) {\n        this.setValues(values, validate, true, notifyChild, notifyParent);\n    }\n\n    /**\n     * Force validation on this form. Required when `validateOnChange` is disabled.\n     */\n    public async validate() {\n        if (!this.validator) {\n            console.warn(\"validate() was called on a form which does not have a validator set.\");\n            return;\n        }\n        this.setErrors(await this.validator(this.values));\n    }\n\n    /**\n     * Sets an error on this form\n     * @param key The field to set an error on.\n     * @param error The error.\n     * @param notifyChild Should this form notify the child form about this change?\n     * @param notifyParent Should this form notify the parent form about this change?\n     * @param fireAny\n     */\n    public setError<Key extends keyof T>(key: Key, error: ErrorType<T[Key], Error> | undefined, notifyChild: boolean = true, notifyParent: boolean = true, fireAny: boolean = true) {\n        if (this.errorMap[key] === error) return;\n\n        if (!error) delete this.errorMap[key];\n        else this.errorMap[key] = error;\n\n        if (notifyChild) this.childMap[key]?.setErrors((error ?? {}) as any);\n        this.fireListeners(key, false);\n        if (fireAny) {\n            if (notifyParent) this.updateParentErrors(); // Will call setError on parent\n            this.fireAnyListeners(false);\n        }\n    }\n\n    /**\n     * Sets all the errors on this form.\n     * @param errors The new errors for this form. Use {} to clear errors. **The format of this error object must follow the same structure of the values object, but each value is replaced by its error.**\n     * @param notifyChild Should this form notify the child form about this change?\n     * @param notifyParent Should this form notify the parent form about this change?\n     */\n    public setErrors(errors: ErrorMap<T, Error>, notifyChild: boolean = true, notifyParent: boolean = true) {\n        let localKeys = Object.keys(this.errorMap);\n        let newKeys = Object.keys(errors);\n        let mostKeys = newKeys.length > localKeys.length ? newKeys : localKeys;\n        for (let i = 0; i < mostKeys.length; i++) {\n            let key = mostKeys[i] as keyof T;\n            this.setError(\n                key,\n                errors[key] as any,\n                notifyChild,\n                notifyParent,\n                false // Will call fireAnyListener by itself, see 3 lines down\n            );\n        }\n        if (notifyParent) this.updateParentErrors();\n        this.fireAnyListeners(false);\n    }\n\n    /**\n     * Reset this form's values to the default values.\n     * @param notifyChild Should this form notify the child form about this change?\n     * @param notifyParent Should this form notify the parent form about this change?\n     */\n    public resetAll(notifyChild: boolean = true, notifyParent: boolean = true) {\n        this.setValues(this.defaultValues, true, false, notifyChild, notifyParent);\n    }\n\n    /**\n     * Reset a form's field to its default value.\n     * @param key The field to reset.\n     * @param notifyChild Should this form notify the child form about this change?\n     * @param notifyParent Should this form notify the parent form about this change?\n     */\n    public reset(key: keyof T, notifyChild: boolean = true, notifyParent: boolean = true) {\n        this.setValue(key, this.defaultValues[key], true, false, notifyChild, notifyParent);\n    }\n\n    /**\n     * Sets the state for this form, and also on child and parent forms by default.\n     * @param newState The new form state.\n     * @param notifyChild Set the state on the child too?\n     * @param notifyParent Set the state on the parent too?\n     */\n    public setState(newState: State, notifyChild: boolean = true, notifyParent: boolean = true) {\n        this._state = newState;\n\n        let c = Object.keys(this.values);\n        if (notifyChild) c.forEach((e) => this.childMap[e]?.setState(newState, notifyChild, notifyParent));\n\n        c.forEach((e) => this.fireListeners(e as keyof T, false));\n        if (notifyParent) this.updateParentState();\n        this.fireAnyListeners(false);\n    }\n\n    /**\n     * Listen for changes on a field, will trigger when value, defaultValue, dirty and error changes for a field. Make sure you pass its return value back to `ignore()` after you are done listening.\n     * @param key The field to listen to.\n     * @param listener Change callback.\n     */\n    public listen(key: keyof T, listener: ListenerCallback): string {\n        if (!this.listeners) this.listeners = {};\n        let setters = this.listeners[key];\n        if (!setters) {\n            setters = {};\n            this.listeners[key] = setters;\n        }\n        let id = \"\" + this.counter++;\n        setters[id] = listener;\n        return id;\n    }\n\n    /**\n     * Listen for any change on this form. Make sure you pass its return value back to `ignoreAny()` after you are done listening.\n     * @param listener Change callback.\n     */\n    public listenAny(listener: ListenerCallback) {\n        if (!this.anyListeners) this.anyListeners = {};\n        let id = \"\" + this.counter++;\n        this.anyListeners[id] = listener;\n        return id;\n    }\n\n    /**\n     * Ignore changes on a field.\n     * @param key The field to ignore.\n     * @param id The callback to ignore.\n     */\n    public ignore(key: keyof T, id: string) {\n        if (!this.listeners) return;\n        let setters = this.listeners[key];\n        if (!setters) {\n            console.warn(\"Ignore was called for no reason\", key, id);\n            return;\n        }\n        delete setters[id];\n    }\n\n    /**\n     * Ignore changes on this form.\n     * @param id The callback to ignore.\n     */\n    public ignoreAny(id: string) {\n        if (!this.anyListeners) return;\n        delete this.anyListeners[id];\n    }\n\n    protected fireListeners(key: keyof T, setValuesWasUsed: boolean) {\n        let a = this.listeners[key];\n        if (a) {\n            let l = Object.keys(a!);\n            l.forEach((e) => a![e]!(setValuesWasUsed));\n        }\n    }\n\n    protected fireAnyListeners(setValuesWasUsed: boolean) {\n        let al = Object.keys(this.anyListeners);\n        al.forEach((e) => this.anyListeners[e]!(setValuesWasUsed));\n    }\n\n    protected updateParentValues(_isDefault: boolean) {\n        // Not implemented for root form, as it does not have a parent\n    }\n\n    protected updateParentErrors() {\n        // Not implemented for root form, as it does not have a parent\n    }\n\n    protected updateParentState() {\n        // Not implemented for root form, as it does not have a parent\n    }\n}\n\nexport class ChildFormState<Parent, ParentState, ParentError, Key extends keyof Parent> extends FormState<NonNullable<Parent[Key]>, ParentState, ParentError> {\n    public name: Key;\n    public readonly parent: FormState<Parent, ParentState, ParentError>;\n\n    public constructor(parent: FormState<Parent, ParentState, ParentError>, name: Key) {\n        super(parent.values[name] ?? ({} as any), parent.defaultValues[name] ?? ({} as any), parent.state);\n        this.parent = parent;\n        this.name = name;\n    }\n\n    protected updateParentValues(isDefault: boolean) {\n        this.parent.setValueInternal(this.name, isDefault ? memberCopy(this.defaultValues) : memberCopy(this.values), this.dirty, true, isDefault, false, true, true);\n    }\n\n    protected updateParentErrors() {\n        this.parent.setError(this.name, this.error ? (memberCopy(this.errorMap) as any) : undefined, false, true);\n    }\n\n    protected updateParentState() {\n        this.parent.setState(memberCopy(this.state), false, true);\n    }\n}\n","import { useRef, useEffect, useState } from \"react\";\nimport { DefaultState, DefaultError, FormState, ChildFormState, Validator } from \"./form\";\n\n/**\n * Creates a new root form.\n * This hook doesn't cause a rerender.\n * @param defaultValues The default values for this form.\n * @param defaultState The default state for this form. Form state contains custom global states, example: isSubmitting, isLoading ...\n * @param validator The validator to use, optional.\n * @param validateOnChange Validate on change?\n */\nexport function useForm<T, State = DefaultState, Error = DefaultError>(\n    defaultValues: T,\n    defaultState: State = { isSubmitting: false } as any,\n    validator?: Validator<T, Error>,\n    validateOnChange = true\n) {\n    let c = useRef<FormState<T, State, Error> | null>(null);\n\n    if (!c.current) {\n        c.current = new FormState(defaultValues, defaultValues, defaultState, validator, validateOnChange);\n    }\n\n    useEffect(() => {\n        c.current!.setValues(defaultValues, true, true);\n    }, [defaultValues]);\n\n    return c.current;\n}\n\n/**\n * Creates a nested form for another root or nested form. You must use this for object and array (see useArrayForm) field.\n * This hook doesn't cause a rerender.\n * @param parentForm The parent form.\n * @param name The parent's field to create a child form for.\n */\nexport function useChildForm<T, State, Error, Key extends keyof T>(parentForm: FormState<T, State, Error>, name: Key) {\n    let c = useRef<ChildFormState<T, State, Error, Key> | null>(null);\n    if (!c.current) {\n        c.current = new ChildFormState(parentForm, name);\n    }\n\n    useEffect(() => {\n        // Update parent and child form\n        parentForm.childMap[name] = c.current!;\n        c.current!.name = name;\n\n        // Set new default values, without notifying children\n        c.current!.setValues(parentForm.defaultValues[name] ?? ({} as any), true, true, false, false);\n        // Then, set new values and notify children\n        c.current!.setValues(parentForm.values[name] ?? ({} as any), true, false, true, false);\n\n        return () => {\n            // Could already be overriden (useEffect ordering)\n            if (parentForm.childMap[name] === c.current!) {\n                delete parentForm.childMap[name];\n                delete parentForm.errorMap[name];\n                delete parentForm.dirtyMap[name];\n            }\n        };\n    }, [parentForm, name]);\n\n    return c.current;\n}\n\n/**\n * Listen for changes on a form's field. Behaves like useState.\n * You shouldn't use this hook in large components, as it rerenders each time something changes. Use the wrapper <Listener /> instead.\n * @param form The form to listen on.\n * @param name The form's field to listen to.\n */\nexport function useListener<T, State, Error, Key extends keyof T>(form: FormState<T, State, Error>, name: Key, onlyOnSetValues = false) {\n    const [, setRender] = useState(0);\n\n    useEffect(() => {\n        let id = form.listen(name, (all) => {\n            if (!onlyOnSetValues || all) setRender((e) => e + 1);\n        });\n        return () => form.ignore(name, id);\n    }, [form, name]);\n\n    return {\n        value: form.values[name],\n        defaultValue: form.defaultValues[name],\n        setValue: (value: T[Key]) => form.setValue(name, value),\n        dirty: form.dirtyMap[name],\n        error: form.errorMap[name],\n        state: form.state,\n        form\n    };\n}\n\n/**\n * Listens for any change on this form. Behaves like useState.\n * You shouldn't use this hook in large components, as it rerenders each time something changes. Use the wrapper <AnyListener /> instead.\n * @param form The form to listen to.\n * @param onlyOnSetValues True if you only want to listen for changes that are set using setValues. (used for arrays)\n */\nexport function useAnyListener<T, State, Error>(form: FormState<T, State, Error>, onlyOnSetValues = false) {\n    const [, setRender] = useState(0);\n\n    useEffect(() => {\n        let id = form.listenAny((all) => {\n            if (!onlyOnSetValues || all) setRender((e) => e + 1);\n        });\n        return () => form.ignoreAny(id);\n    }, [form]);\n\n    return form;\n}\n\n/**\n * This is a wrapper around useChildForm, with useful functions to manipulate arrays.\n * This hook does cause a rerender, but only if the whole array changes.\n * @param parentForm The parent form.\n * @param name The parent's field to create a child form for.\n */\nexport function useArrayForm<Parent, ParentState, ParentError, Key extends keyof Parent>(parentForm: FormState<Parent, ParentState, ParentError>, name: Key) {\n    const form = useChildForm<Parent, ParentState, ParentError, Key>(parentForm, name);\n    useAnyListener(form, true);\n\n    function append(value: Parent[Key][keyof Parent[Key]]) {\n        form.setValues([...(form.values as any), value] as any);\n    }\n\n    function remove(index: number) {\n        let newValues = [...(form.values as any)];\n        newValues.splice(index, 1);\n        form.setValues(newValues as any);\n    }\n\n    function clear() {\n        form.setValues([] as any);\n    }\n\n    function move(from: number, to: number) {\n        if (to === from) return;\n        let newArr = [...(form.values as any)];\n        var target = newArr[from];\n        var increment = to < from ? -1 : 1;\n        for (var k = from; k !== to; k += increment) {\n            newArr[k] = newArr[k + increment];\n        }\n        newArr[to] = target;\n        form.setValues(newArr as any);\n    }\n\n    function swap(index: number, newIndex: number) {\n        if (index === newIndex) {\n            return;\n        }\n        let values = [...(form.values as any)];\n        [values[index], values[newIndex]] = [values[newIndex], values[index]];\n        form.setValues(values as any);\n    }\n\n    return {\n        remove,\n        move,\n        swap,\n        clear,\n        append,\n        form: form,\n        values: form.values,\n        setValues: form.setValues.bind(form)\n    };\n}\n","import React, { useMemo } from \"react\";\nimport { InputHTMLAttributes } from \"react\";\nimport { DefaultState, FormState } from \"../form\";\nimport { useListener } from \"../hooks\";\n\ntype BaldInputProps = Omit<InputHTMLAttributes<HTMLInputElement>, \"name\" | \"form\" | \"value\">;\n\nexport const DEFAULT_DIRTY_CLASS = \"typed-form-dirty\";\nexport const DEFAULT_ERROR_CLASS = \"typed-form-error\";\n\nexport function getClassName(...args: any) {\n    return [...args].filter((e) => !!e).join(\" \");\n}\n\nexport type FormInputCheckMode = \"normal\" | \"setNull\" | \"setUndefined\";\n\nexport type FormInputProps<T, State, Error, Key extends keyof T, Value extends T[Key] | T[Key][keyof T[Key]]> = BaldInputProps & {\n    form: FormState<T, State, Error>;\n    name: Key;\n    value?: Value;\n    errorClassName?: string;\n    errorStyle?: React.CSSProperties;\n    dirtyClassName?: string;\n    dirtyStyle?: React.CSSProperties;\n    disableOnSubmitting?: boolean;\n    dateAsNumber?: boolean;\n    setNullOnUncheck?: boolean;\n    setUndefinedOnUncheck?: boolean;\n    hideWhenNull?: boolean;\n};\n\nexport function FormInput<T, State extends DefaultState, Error, Key extends keyof T, Value extends T[Key] | T[Key][keyof T[Key]]>({\n    form,\n    name,\n    style,\n    className,\n    disableOnSubmitting,\n    dateAsNumber,\n    errorClassName,\n    errorStyle,\n    dirtyClassName,\n    dirtyStyle,\n    setUndefinedOnUncheck,\n    setNullOnUncheck,\n    hideWhenNull,\n    value: inputValue,\n    checked: inputChecked,\n    ...rest\n}: FormInputProps<T, State, Error, Key, Value>) {\n    const { value: currentValue, error, dirty, state, setValue, defaultValue } = useListener(form, name);\n\n    let [inValue, inChecked] = useMemo(() => {\n        let inValue = undefined,\n            inChecked = undefined;\n        switch (rest.type) {\n            case \"number\": {\n                inValue = (currentValue ?? \"\") + \"\";\n                break;\n            }\n            case \"datetime-local\":\n            case \"date\": {\n                let n = currentValue as any;\n                if (typeof n === \"string\") {\n                    let ni = parseInt(n);\n                    if (!isNaN(ni)) n = ni;\n                }\n                let d = new Date(n);\n                if (d.getTime() === d.getTime()) {\n                    // Trick to check if date is valid: NaN === NaN returns false\n                    inValue = d?.toISOString().split(\"T\")[0] ?? \"\";\n                } else {\n                    inValue = \"\";\n                }\n                break;\n            }\n            case \"radio\": {\n                inChecked = currentValue === inputValue;\n                break;\n            }\n            case \"checkbox\": {\n                if (setNullOnUncheck) {\n                    inChecked = currentValue !== null;\n                } else if (setUndefinedOnUncheck) {\n                    inChecked = currentValue !== undefined;\n                } else if (inputValue !== undefined) {\n                    inChecked = (Array.isArray(currentValue) ? currentValue : []).includes(inputValue as never);\n                } else {\n                    inChecked = !!currentValue;\n                }\n                break;\n            }\n            default: {\n                inValue = (currentValue ?? \"\") + \"\";\n                break;\n            }\n        }\n        return [inValue, inChecked];\n    }, [rest.type, currentValue, inputValue]);\n\n    if (hideWhenNull && (currentValue === null || currentValue === undefined)) return null;\n\n    if ((setNullOnUncheck || setUndefinedOnUncheck) && rest.type !== \"checkbox\") console.warn(\"setNullOnUncheck/setUndefinedOnUncheck only has an effect on checkboxes.\");\n\n    return (\n        <input\n            style={{\n                ...style,\n                ...(dirty && dirtyStyle),\n                ...(error && errorStyle)\n            }}\n            className={getClassName(className, dirty && (dirtyClassName ?? DEFAULT_DIRTY_CLASS), error && (errorClassName ?? DEFAULT_ERROR_CLASS))}\n            disabled={(disableOnSubmitting ?? true) && state.isSubmitting}\n            value={inValue}\n            checked={inChecked}\n            onChange={(ev) => {\n                let newValue = ev.target.value;\n                let newChecked = ev.target.checked;\n                switch (rest.type) {\n                    case \"number\": {\n                        setValue(parseFloat(newValue) as any);\n                        return;\n                    }\n                    case \"datetime-local\":\n                    case \"date\": {\n                        if (newValue) {\n                            let d = new Date(newValue);\n                            setValue((dateAsNumber ? d.getTime() : d) as any);\n                        } else {\n                            setValue(null as any);\n                        }\n                        return;\n                    }\n                    case \"radio\": {\n                        // Enum field\n                        if (newChecked) {\n                            setValue(inputValue as any);\n                        }\n                        return;\n                    }\n                    case \"checkbox\": {\n                        if (setNullOnUncheck || setUndefinedOnUncheck) {\n                            if (newChecked && inputValue === undefined && !defaultValue)\n                                console.warn(\"Toggling checkbox using setNullOnUncheck got checked but a value to set was not found, please provide the value prop\");\n                            setValue(newChecked ? (inputValue !== undefined ? inputValue : defaultValue) : ((setNullOnUncheck ? null : undefined) as any));\n                        } else if (inputValue !== undefined) {\n                            // Primitive array field\n                            let arr = Array.isArray(currentValue) ? [...currentValue] : [];\n                            if (newChecked) arr.push(inputValue);\n                            else arr.splice(arr.indexOf(inputValue), 1);\n                            setValue(arr as any);\n                        } else {\n                            // Boolean field\n                            setValue(newChecked as any);\n                        }\n                        return;\n                    }\n                    default: {\n                        // String field\n                        setValue(newValue as any);\n                        return;\n                    }\n                }\n            }}\n            name={name as string}\n            {...rest}\n        />\n    );\n}\n","// A type of promise-like that resolves synchronously and supports only one observer\nexport const _Pact = /*#__PURE__*/(function() {\n\tfunction _Pact() {}\n\t_Pact.prototype.then = function(onFulfilled, onRejected) {\n\t\tconst result = new _Pact();\n\t\tconst state = this.s;\n\t\tif (state) {\n\t\t\tconst callback = state & 1 ? onFulfilled : onRejected;\n\t\t\tif (callback) {\n\t\t\t\ttry {\n\t\t\t\t\t_settle(result, 1, callback(this.v));\n\t\t\t\t} catch (e) {\n\t\t\t\t\t_settle(result, 2, e);\n\t\t\t\t}\n\t\t\t\treturn result;\n\t\t\t} else {\n\t\t\t\treturn this;\n\t\t\t}\n\t\t}\n\t\tthis.o = function(_this) {\n\t\t\ttry {\n\t\t\t\tconst value = _this.v;\n\t\t\t\tif (_this.s & 1) {\n\t\t\t\t\t_settle(result, 1, onFulfilled ? onFulfilled(value) : value);\n\t\t\t\t} else if (onRejected) {\n\t\t\t\t\t_settle(result, 1, onRejected(value));\n\t\t\t\t} else {\n\t\t\t\t\t_settle(result, 2, value);\n\t\t\t\t}\n\t\t\t} catch (e) {\n\t\t\t\t_settle(result, 2, e);\n\t\t\t}\n\t\t};\n\t\treturn result;\n\t}\n\treturn _Pact;\n})();\n\n// Settles a pact synchronously\nexport function _settle(pact, state, value) {\n\tif (!pact.s) {\n\t\tif (value instanceof _Pact) {\n\t\t\tif (value.s) {\n\t\t\t\tif (state & 1) {\n\t\t\t\t\tstate = value.s;\n\t\t\t\t}\n\t\t\t\tvalue = value.v;\n\t\t\t} else {\n\t\t\t\tvalue.o = _settle.bind(null, pact, state);\n\t\t\t\treturn;\n\t\t\t}\n\t\t}\n\t\tif (value && value.then) {\n\t\t\tvalue.then(_settle.bind(null, pact, state), _settle.bind(null, pact, 2));\n\t\t\treturn;\n\t\t}\n\t\tpact.s = state;\n\t\tpact.v = value;\n\t\tconst observer = pact.o;\n\t\tif (observer) {\n\t\t\tobserver(pact);\n\t\t}\n\t}\n}\n\nexport function _isSettledPact(thenable) {\n\treturn thenable instanceof _Pact && thenable.s & 1;\n}\n\n// Converts argument to a function that always returns a Promise\nexport function _async(f) {\n\treturn function() {\n\t\tfor (var args = [], i = 0; i < arguments.length; i++) {\n\t\t\targs[i] = arguments[i];\n\t\t}\n\t\ttry {\n\t\t\treturn Promise.resolve(f.apply(this, args));\n\t\t} catch(e) {\n\t\t\treturn Promise.reject(e);\n\t\t}\n\t}\n}\n\n// Awaits on a value that may or may not be a Promise (equivalent to the await keyword in ES2015, with continuations passed explicitly)\nexport function _await(value, then, direct) {\n\tif (direct) {\n\t\treturn then ? then(value) : value;\n\t}\n\tif (!value || !value.then) {\n\t\tvalue = Promise.resolve(value);\n\t}\n\treturn then ? value.then(then) : value;\n}\n\n// Awaits on a value that may or may not be a Promise, then ignores it\nexport function _awaitIgnored(value, direct) {\n\tif (!direct) {\n\t\treturn value && value.then ? value.then(_empty) : Promise.resolve();\n\t}\n}\n\n// Proceeds after a value has resolved, or proceeds immediately if the value is not thenable\nexport function _continue(value, then) {\n\treturn value && value.then ? value.then(then) : then(value);\n}\n\n// Proceeds after a value has resolved, or proceeds immediately if the value is not thenable\nexport function _continueIgnored(value) {\n\tif (value && value.then) {\n\t\treturn value.then(_empty);\n\t}\n}\n\n// Asynchronously iterate through an object that has a length property, passing the index as the first argument to the callback (even as the length property changes)\nexport function _forTo(array, body, check) {\n\tvar i = -1, pact, reject;\n\tfunction _cycle(result) {\n\t\ttry {\n\t\t\twhile (++i < array.length && (!check || !check())) {\n\t\t\t\tresult = body(i);\n\t\t\t\tif (result && result.then) {\n\t\t\t\t\tif (_isSettledPact(result)) {\n\t\t\t\t\t\tresult = result.v;\n\t\t\t\t\t} else {\n\t\t\t\t\t\tresult.then(_cycle, reject || (reject = _settle.bind(null, pact = new _Pact(), 2)));\n\t\t\t\t\t\treturn;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (pact) {\n\t\t\t\t_settle(pact, 1, result);\n\t\t\t} else {\n\t\t\t\tpact = result;\n\t\t\t}\n\t\t} catch (e) {\n\t\t\t_settle(pact || (pact = new _Pact()), 2, e);\n\t\t}\n\t}\n\t_cycle();\n\treturn pact;\n}\n\n// Asynchronously iterate through an object's properties (including properties inherited from the prototype)\n// Uses a snapshot of the object's properties\nexport function _forIn(target, body, check) {\n\tvar keys = [];\n\tfor (var key in target) {\n\t\tkeys.push(key);\n\t}\n\treturn _forTo(keys, function(i) { return body(keys[i]); }, check);\n}\n\n// Asynchronously iterate through an object's own properties (excluding properties inherited from the prototype)\n// Uses a snapshot of the object's properties\nexport function _forOwn(target, body, check) {\n\tvar keys = [];\n\tfor (var key in target) {\n\t\tif (Object.prototype.hasOwnProperty.call(target, key)) {\n\t\t\tkeys.push(key);\n\t\t}\n\t}\n\treturn _forTo(keys, function(i) { return body(keys[i]); }, check);\n}\n\nexport const _iteratorSymbol = /*#__PURE__*/ typeof Symbol !== \"undefined\" ? (Symbol.iterator || (Symbol.iterator = Symbol(\"Symbol.iterator\"))) : \"@@iterator\";\n\n// Asynchronously iterate through an object's values\n// Uses for...of if the runtime supports it, otherwise iterates until length on a copy\nexport function _forOf(target, body, check) {\n\tif (typeof target[_iteratorSymbol] === \"function\") {\n\t\tvar iterator = target[_iteratorSymbol](), step, pact, reject;\n\t\tfunction _cycle(result) {\n\t\t\ttry {\n\t\t\t\twhile (!(step = iterator.next()).done && (!check || !check())) {\n\t\t\t\t\tresult = body(step.value);\n\t\t\t\t\tif (result && result.then) {\n\t\t\t\t\t\tif (_isSettledPact(result)) {\n\t\t\t\t\t\t\tresult = result.v;\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tresult.then(_cycle, reject || (reject = _settle.bind(null, pact = new _Pact(), 2)));\n\t\t\t\t\t\t\treturn;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif (pact) {\n\t\t\t\t\t_settle(pact, 1, result);\n\t\t\t\t} else {\n\t\t\t\t\tpact = result;\n\t\t\t\t}\n\t\t\t} catch (e) {\n\t\t\t\t_settle(pact || (pact = new _Pact()), 2, e);\n\t\t\t}\n\t\t}\n\t\t_cycle();\n\t\tif (iterator.return) {\n\t\t\tvar _fixup = function(value) {\n\t\t\t\ttry {\n\t\t\t\t\tif (!step.done) {\n\t\t\t\t\t\titerator.return();\n\t\t\t\t\t}\n\t\t\t\t} catch(e) {\n\t\t\t\t}\n\t\t\t\treturn value;\n\t\t\t}\n\t\t\tif (pact && pact.then) {\n\t\t\t\treturn pact.then(_fixup, function(e) {\n\t\t\t\t\tthrow _fixup(e);\n\t\t\t\t});\n\t\t\t}\n\t\t\t_fixup();\n\t\t}\n\t\treturn pact;\n\t}\n\t// No support for Symbol.iterator\n\tif (!(\"length\" in target)) {\n\t\tthrow new TypeError(\"Object is not iterable\");\n\t}\n\t// Handle live collections properly\n\tvar values = [];\n\tfor (var i = 0; i < target.length; i++) {\n\t\tvalues.push(target[i]);\n\t}\n\treturn _forTo(values, function(i) { return body(values[i]); }, check);\n}\n\nexport const _asyncIteratorSymbol = /*#__PURE__*/ typeof Symbol !== \"undefined\" ? (Symbol.asyncIterator || (Symbol.asyncIterator = Symbol(\"Symbol.asyncIterator\"))) : \"@@asyncIterator\";\n\n// Asynchronously iterate on a value using it's async iterator if present, or its synchronous iterator if missing\nexport function _forAwaitOf(target, body, check) {\n\tif (typeof target[_asyncIteratorSymbol] === \"function\") {\n\t\tvar pact = new _Pact();\n\t\tvar iterator = target[_asyncIteratorSymbol]();\n\t\titerator.next().then(_resumeAfterNext).then(void 0, _reject);\n\t\treturn pact;\n\t\tfunction _resumeAfterBody(result) {\n\t\t\tif (check && check()) {\n\t\t\t\treturn _settle(pact, 1, iterator.return ? iterator.return().then(function() { return result; }) : result);\n\t\t\t}\n\t\t\titerator.next().then(_resumeAfterNext).then(void 0, _reject);\n\t\t}\n\t\tfunction _resumeAfterNext(step) {\n\t\t\tif (step.done) {\n\t\t\t\t_settle(pact, 1);\n\t\t\t} else {\n\t\t\t\tPromise.resolve(body(step.value)).then(_resumeAfterBody).then(void 0, _reject);\n\t\t\t}\n\t\t}\n\t\tfunction _reject(error) {\n\t\t\t_settle(pact, 2, iterator.return ? iterator.return().then(function() { return error; }) : error);\n\t\t}\n\t}\n\treturn Promise.resolve(_forOf(target, function(value) { return Promise.resolve(value).then(body); }, check));\n}\n\n// Asynchronously implement a generic for loop\nexport function _for(test, update, body) {\n\tvar stage;\n\tfor (;;) {\n\t\tvar shouldContinue = test();\n\t\tif (_isSettledPact(shouldContinue)) {\n\t\t\tshouldContinue = shouldContinue.v;\n\t\t}\n\t\tif (!shouldContinue) {\n\t\t\treturn result;\n\t\t}\n\t\tif (shouldContinue.then) {\n\t\t\tstage = 0;\n\t\t\tbreak;\n\t\t}\n\t\tvar result = body();\n\t\tif (result && result.then) {\n\t\t\tif (_isSettledPact(result)) {\n\t\t\t\tresult = result.s;\n\t\t\t} else {\n\t\t\t\tstage = 1;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tif (update) {\n\t\t\tvar updateValue = update();\n\t\t\tif (updateValue && updateValue.then && !_isSettledPact(updateValue)) {\n\t\t\t\tstage = 2;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n\tvar pact = new _Pact();\n\tvar reject = _settle.bind(null, pact, 2);\n\t(stage === 0 ? shouldContinue.then(_resumeAfterTest) : stage === 1 ? result.then(_resumeAfterBody) : updateValue.then(_resumeAfterUpdate)).then(void 0, reject);\n\treturn pact;\n\tfunction _resumeAfterBody(value) {\n\t\tresult = value;\n\t\tdo {\n\t\t\tif (update) {\n\t\t\t\tupdateValue = update();\n\t\t\t\tif (updateValue && updateValue.then && !_isSettledPact(updateValue)) {\n\t\t\t\t\tupdateValue.then(_resumeAfterUpdate).then(void 0, reject);\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t}\n\t\t\tshouldContinue = test();\n\t\t\tif (!shouldContinue || (_isSettledPact(shouldContinue) && !shouldContinue.v)) {\n\t\t\t\t_settle(pact, 1, result);\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tif (shouldContinue.then) {\n\t\t\t\tshouldContinue.then(_resumeAfterTest).then(void 0, reject);\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tresult = body();\n\t\t\tif (_isSettledPact(result)) {\n\t\t\t\tresult = result.v;\n\t\t\t}\n\t\t} while (!result || !result.then);\n\t\tresult.then(_resumeAfterBody).then(void 0, reject);\n\t}\n\tfunction _resumeAfterTest(shouldContinue) {\n\t\tif (shouldContinue) {\n\t\t\tresult = body();\n\t\t\tif (result && result.then) {\n\t\t\t\tresult.then(_resumeAfterBody).then(void 0, reject);\n\t\t\t} else {\n\t\t\t\t_resumeAfterBody(result);\n\t\t\t}\n\t\t} else {\n\t\t\t_settle(pact, 1, result);\n\t\t}\n\t}\n\tfunction _resumeAfterUpdate() {\n\t\tif (shouldContinue = test()) {\n\t\t\tif (shouldContinue.then) {\n\t\t\t\tshouldContinue.then(_resumeAfterTest).then(void 0, reject);\n\t\t\t} else {\n\t\t\t\t_resumeAfterTest(shouldContinue);\n\t\t\t}\n\t\t} else {\n\t\t\t_settle(pact, 1, result);\n\t\t}\n\t}\n}\n\n// Asynchronously implement a do ... while loop\nexport function _do(body, test) {\n\tvar awaitBody;\n\tdo {\n\t\tvar result = body();\n\t\tif (result && result.then) {\n\t\t\tif (_isSettledPact(result)) {\n\t\t\t\tresult = result.v;\n\t\t\t} else {\n\t\t\t\tawaitBody = true;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tvar shouldContinue = test();\n\t\tif (_isSettledPact(shouldContinue)) {\n\t\t\tshouldContinue = shouldContinue.v;\n\t\t}\n\t\tif (!shouldContinue) {\n\t\t\treturn result;\n\t\t}\n\t} while (!shouldContinue.then);\n\tconst pact = new _Pact();\n\tconst reject = _settle.bind(null, pact, 2);\n\t(awaitBody ? result.then(_resumeAfterBody) : shouldContinue.then(_resumeAfterTest)).then(void 0, reject);\n\treturn pact;\n\tfunction _resumeAfterBody(value) {\n\t\tresult = value;\n\t\tfor (;;) {\n\t\t\tshouldContinue = test();\n\t\t\tif (_isSettledPact(shouldContinue)) {\n\t\t\t\tshouldContinue = shouldContinue.v;\n\t\t\t}\n\t\t\tif (!shouldContinue) {\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tif (shouldContinue.then) {\n\t\t\t\tshouldContinue.then(_resumeAfterTest).then(void 0, reject);\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tresult = body();\n\t\t\tif (result && result.then) {\n\t\t\t\tif (_isSettledPact(result)) {\n\t\t\t\t\tresult = result.v;\n\t\t\t\t} else {\n\t\t\t\t\tresult.then(_resumeAfterBody).then(void 0, reject);\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t_settle(pact, 1, result);\n\t}\n\tfunction _resumeAfterTest(shouldContinue) {\n\t\tif (shouldContinue) {\n\t\t\tdo {\n\t\t\t\tresult = body();\n\t\t\t\tif (result && result.then) {\n\t\t\t\t\tif (_isSettledPact(result)) {\n\t\t\t\t\t\tresult = result.v;\n\t\t\t\t\t} else {\n\t\t\t\t\t\tresult.then(_resumeAfterBody).then(void 0, reject);\n\t\t\t\t\t\treturn;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tshouldContinue = test();\n\t\t\t\tif (_isSettledPact(shouldContinue)) {\n\t\t\t\t\tshouldContinue = shouldContinue.v;\n\t\t\t\t}\n\t\t\t\tif (!shouldContinue) {\n\t\t\t\t\t_settle(pact, 1, result);\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t} while (!shouldContinue.then);\n\t\t\tshouldContinue.then(_resumeAfterTest).then(void 0, reject);\n\t\t} else {\n\t\t\t_settle(pact, 1, result);\n\t\t}\n\t}\n}\n\n// Asynchronously implement a switch statement\nexport function _switch(discriminant, cases) {\n\tvar dispatchIndex = -1;\n\tvar awaitBody;\n\touter: {\n\t\tfor (var i = 0; i < cases.length; i++) {\n\t\t\tvar test = cases[i][0];\n\t\t\tif (test) {\n\t\t\t\tvar testValue = test();\n\t\t\t\tif (testValue && testValue.then) {\n\t\t\t\t\tbreak outer;\n\t\t\t\t}\n\t\t\t\tif (testValue === discriminant) {\n\t\t\t\t\tdispatchIndex = i;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\t// Found the default case, set it as the pending dispatch case\n\t\t\t\tdispatchIndex = i;\n\t\t\t}\n\t\t}\n\t\tif (dispatchIndex !== -1) {\n\t\t\tdo {\n\t\t\t\tvar body = cases[dispatchIndex][1];\n\t\t\t\twhile (!body) {\n\t\t\t\t\tdispatchIndex++;\n\t\t\t\t\tbody = cases[dispatchIndex][1];\n\t\t\t\t}\n\t\t\t\tvar result = body();\n\t\t\t\tif (result && result.then) {\n\t\t\t\t\tawaitBody = true;\n\t\t\t\t\tbreak outer;\n\t\t\t\t}\n\t\t\t\tvar fallthroughCheck = cases[dispatchIndex][2];\n\t\t\t\tdispatchIndex++;\n\t\t\t} while (fallthroughCheck && !fallthroughCheck());\n\t\t\treturn result;\n\t\t}\n\t}\n\tconst pact = new _Pact();\n\tconst reject = _settle.bind(null, pact, 2);\n\t(awaitBody ? result.then(_resumeAfterBody) : testValue.then(_resumeAfterTest)).then(void 0, reject);\n\treturn pact;\n\tfunction _resumeAfterTest(value) {\n\t\tfor (;;) {\n\t\t\tif (value === discriminant) {\n\t\t\t\tdispatchIndex = i;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tif (++i === cases.length) {\n\t\t\t\tif (dispatchIndex !== -1) {\n\t\t\t\t\tbreak;\n\t\t\t\t} else {\n\t\t\t\t\t_settle(pact, 1, result);\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t}\n\t\t\ttest = cases[i][0];\n\t\t\tif (test) {\n\t\t\t\tvalue = test();\n\t\t\t\tif (value && value.then) {\n\t\t\t\t\tvalue.then(_resumeAfterTest).then(void 0, reject);\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tdispatchIndex = i;\n\t\t\t}\n\t\t}\n\t\tdo {\n\t\t\tvar body = cases[dispatchIndex][1];\n\t\t\twhile (!body) {\n\t\t\t\tdispatchIndex++;\n\t\t\t\tbody = cases[dispatchIndex][1];\n\t\t\t}\n\t\t\tvar result = body();\n\t\t\tif (result && result.then) {\n\t\t\t\tresult.then(_resumeAfterBody).then(void 0, reject);\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tvar fallthroughCheck = cases[dispatchIndex][2];\n\t\t\tdispatchIndex++;\n\t\t} while (fallthroughCheck && !fallthroughCheck());\n\t\t_settle(pact, 1, result);\n\t}\n\tfunction _resumeAfterBody(result) {\n\t\tfor (;;) {\n\t\t\tvar fallthroughCheck = cases[dispatchIndex][2];\n\t\t\tif (!fallthroughCheck || fallthroughCheck()) {\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tdispatchIndex++;\n\t\t\tvar body = cases[dispatchIndex][1];\n\t\t\twhile (!body) {\n\t\t\t\tdispatchIndex++;\n\t\t\t\tbody = cases[dispatchIndex][1];\n\t\t\t}\n\t\t\tresult = body();\n\t\t\tif (result && result.then) {\n\t\t\t\tresult.then(_resumeAfterBody).then(void 0, reject);\n\t\t\t\treturn;\n\t\t\t}\n\t\t}\n\t\t_settle(pact, 1, result);\n\t}\n}\n\n// Asynchronously call a function and pass the result to explicitly passed continuations\nexport function _call(body, then, direct) {\n\tif (direct) {\n\t\treturn then ? then(body()) : body();\n\t}\n\ttry {\n\t\tvar result = Promise.resolve(body());\n\t\treturn then ? result.then(then) : result;\n\t} catch (e) {\n\t\treturn Promise.reject(e);\n\t}\n}\n\n// Asynchronously call a function and swallow the result\nexport function _callIgnored(body, direct) {\n\treturn _call(body, _empty, direct);\n}\n\n// Asynchronously call a function and pass the result to explicitly passed continuations\nexport function _invoke(body, then) {\n\tvar result = body();\n\tif (result && result.then) {\n\t\treturn result.then(then);\n\t}\n\treturn then(result);\n}\n\n// Asynchronously call a function and swallow the result\nexport function _invokeIgnored(body) {\n\tvar result = body();\n\tif (result && result.then) {\n\t\treturn result.then(_empty);\n\t}\n}\n\n// Asynchronously call a function and send errors to recovery continuation\nexport function _catch(body, recover) {\n\ttry {\n\t\tvar result = body();\n\t} catch(e) {\n\t\treturn recover(e);\n\t}\n\tif (result && result.then) {\n\t\treturn result.then(void 0, recover);\n\t}\n\treturn result;\n}\n\n// Asynchronously await a promise and pass the result to a finally continuation\nexport function _finallyRethrows(body, finalizer) {\n\ttry {\n\t\tvar result = body();\n\t} catch (e) {\n\t\treturn finalizer(true, e);\n\t}\n\tif (result && result.then) {\n\t\treturn result.then(finalizer.bind(null, false), finalizer.bind(null, true));\n\t}\n\treturn finalizer(false, result);\n}\n\n// Asynchronously await a promise and invoke a finally continuation that always overrides the result\nexport function _finally(body, finalizer) {\n\ttry {\n\t\tvar result = body();\n\t} catch (e) {\n\t\treturn finalizer();\n\t}\n\tif (result && result.then) {\n\t\treturn result.then(finalizer, finalizer);\n\t}\n\treturn finalizer();\n}\n\n// Rethrow or return a value from a finally continuation\nexport function _rethrow(thrown, value) {\n\tif (thrown)\n\t\tthrow value;\n\treturn value;\n}\n\n// Empty function to implement break and other control flow that ignores asynchronous results\nexport function _empty() {\n}\n\n// Sentinel value for early returns in generators \nexport const _earlyReturn = /*#__PURE__*/ {};\n\n// Asynchronously call a function and send errors to recovery continuation, skipping early returns\nexport function _catchInGenerator(body, recover) {\n\treturn _catch(body, function(e) {\n\t\tif (e === _earlyReturn) {\n\t\t\tthrow e;\n\t\t}\n\t\treturn recover(e);\n\t});\n}\n\n// Asynchronous generator class; accepts the entrypoint of the generator, to which it passes itself when the generator should start\nexport const _AsyncGenerator = /*#__PURE__*/(function() {\n\tfunction _AsyncGenerator(entry) {\n\t\tthis._entry = entry;\n\t\tthis._pact = null;\n\t\tthis._resolve = null;\n\t\tthis._return = null;\n\t\tthis._promise = null;\n\t}\n\n\tfunction _wrapReturnedValue(value) {\n\t\treturn { value: value, done: true };\n\t}\n\tfunction _wrapYieldedValue(value) {\n\t\treturn { value: value, done: false };\n\t}\n\n\t_AsyncGenerator.prototype._yield = function(value) {\n\t\t// Yield the value to the pending next call\n\t\tthis._resolve(value && value.then ? value.then(_wrapYieldedValue) : _wrapYieldedValue(value));\n\t\t// Return a pact for an upcoming next/return/throw call\n\t\treturn this._pact = new _Pact();\n\t};\n\t_AsyncGenerator.prototype.next = function(value) {\n\t\t// Advance the generator, starting it if it has yet to be started\n\t\tconst _this = this;\n\t\treturn _this._promise = new Promise(function (resolve) {\n\t\t\tconst _pact = _this._pact;\n\t\t\tif (_pact === null) {\n\t\t\t\tconst _entry = _this._entry;\n\t\t\t\tif (_entry === null) {\n\t\t\t\t\t// Generator is started, but not awaiting a yield expression\n\t\t\t\t\t// Abandon the next call!\n\t\t\t\t\treturn resolve(_this._promise);\n\t\t\t\t}\n\t\t\t\t// Start the generator\n\t\t\t\t_this._entry = null;\n\t\t\t\t_this._resolve = resolve;\n\t\t\t\tfunction returnValue(value) {\n\t\t\t\t\t_this._resolve(value && value.then ? value.then(_wrapReturnedValue) : _wrapReturnedValue(value));\n\t\t\t\t\t_this._pact = null;\n\t\t\t\t\t_this._resolve = null;\n\t\t\t\t}\n\t\t\t\tvar result = _entry(_this);\n\t\t\t\tif (result && result.then) {\n\t\t\t\t\tresult.then(returnValue, function(error) {\n\t\t\t\t\t\tif (error === _earlyReturn) {\n\t\t\t\t\t\t\treturnValue(_this._return);\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tconst pact = new _Pact();\n\t\t\t\t\t\t\t_this._resolve(pact);\n\t\t\t\t\t\t\t_this._pact = null;\n\t\t\t\t\t\t\t_this._resolve = null;\n\t\t\t\t\t\t\t_resolve(pact, 2, error);\n\t\t\t\t\t\t}\n\t\t\t\t\t});\n\t\t\t\t} else {\n\t\t\t\t\treturnValue(result);\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\t// Generator is started and a yield expression is pending, settle it\n\t\t\t\t_this._pact = null;\n\t\t\t\t_this._resolve = resolve;\n\t\t\t\t_settle(_pact, 1, value);\n\t\t\t}\n\t\t});\n\t};\n\t_AsyncGenerator.prototype.return = function(value) {\n\t\t// Early return from the generator if started, otherwise abandons the generator\n\t\tconst _this = this;\n\t\treturn _this._promise = new Promise(function (resolve) {\n\t\t\tconst _pact = _this._pact;\n\t\t\tif (_pact === null) {\n\t\t\t\tif (_this._entry === null) {\n\t\t\t\t\t// Generator is started, but not awaiting a yield expression\n\t\t\t\t\t// Abandon the return call!\n\t\t\t\t\treturn resolve(_this._promise);\n\t\t\t\t}\n\t\t\t\t// Generator is not started, abandon it and return the specified value\n\t\t\t\t_this._entry = null;\n\t\t\t\treturn resolve(value && value.then ? value.then(_wrapReturnedValue) : _wrapReturnedValue(value));\n\t\t\t}\n\t\t\t// Settle the yield expression with a rejected \"early return\" value\n\t\t\t_this._return = value;\n\t\t\t_this._resolve = resolve;\n\t\t\t_this._pact = null;\n\t\t\t_settle(_pact, 2, _earlyReturn);\n\t\t});\n\t};\n\t_AsyncGenerator.prototype.throw = function(error) {\n\t\t// Inject an exception into the pending yield expression\n\t\tconst _this = this;\n\t\treturn _this._promise = new Promise(function (resolve, reject) {\n\t\t\tconst _pact = _this._pact;\n\t\t\tif (_pact === null) {\n\t\t\t\tif (_this._entry === null) {\n\t\t\t\t\t// Generator is started, but not awaiting a yield expression\n\t\t\t\t\t// Abandon the throw call!\n\t\t\t\t\treturn resolve(_this._promise);\n\t\t\t\t}\n\t\t\t\t// Generator is not started, abandon it and return a rejected Promise containing the error\n\t\t\t\t_this._entry = null;\n\t\t\t\treturn reject(error);\n\t\t\t}\n\t\t\t// Settle the yield expression with the value as a rejection\n\t\t\t_this._resolve = resolve;\n\t\t\t_this._pact = null;\n\t\t\t_settle(_pact, 2, error);\n\t\t});\n\t};\n\n\t_AsyncGenerator.prototype[_asyncIteratorSymbol] = function() {\n\t\treturn this;\n\t};\n\t\n\treturn _AsyncGenerator;\n})();\n","import { Validator } from \"./form\";\n\n// yup type stubs\ninterface YupValidationError {\n    path?: string;\n    message?: string;\n    inner: YupValidationError[];\n}\ninterface YupValidationOptions {\n    strict?: boolean;\n    abortEarly?: boolean;\n    stripUnknown?: boolean;\n    recursive?: boolean;\n    context?: any;\n}\n\nexport function yupValidator<T, Error>(yupSchema: any, options?: YupValidationOptions, messageTransformer: (message: string) => Error = (e) => e as any): Validator<T, Error> {\n    return async (values: T) => {\n        try {\n            await yupSchema.validate(values, options);\n            return {};\n        } catch (ex) {\n            return yupErrorToErrorMap(ex, messageTransformer);\n        }\n    };\n}\n\nexport function yupErrorToErrorMap<Error>(error: YupValidationError, errorTransformer: (message: string) => Error) {\n    let errors = error.path ? [error] : error.inner;\n    let obj = {};\n    for (let i = 0; i < errors.length; i++) {\n        let err = errors[i];\n        if (!err.path || !err.message) continue;\n        let pathSegments = Array.from(err.path.matchAll(/(\\w+)/gi)).map((e) => e[0]);\n        let o = obj;\n        for (let j = 0; j < pathSegments.length; j++) {\n            let key = pathSegments[j];\n            let oo = o[key];\n            if (!oo) {\n                oo = {};\n                o[key] = oo;\n            }\n            if (j === pathSegments.length - 1) {\n                o[key] = errorTransformer(err.message);\n            } else {\n                o = oo;\n            }\n        }\n    }\n    return obj;\n}\n","import React from \"react\";\nimport { ChildFormState, DirtyMap, ErrorMap, FormState } from \"./form\";\nimport { useArrayForm, useListener, useAnyListener, useChildForm } from \"./hooks\";\n\n/**\n * Wrapper around useArrayForm (which is a wrapper around useChildForm).\n * Exports useful functions to manipulate arrays.\n * This hook does cause a rerender, but only if the whole array changes.\n * @param parent The parent form.\n * @param name The parent's field to create a child form for.\n */\nexport function ArrayForm<Parent, ParentState, ParentError, Key extends keyof Parent>(props: {\n    form: FormState<Parent, ParentState, ParentError>;\n    name: Key;\n    render?: (props: {\n        form: ChildFormState<Parent, ParentState, ParentError, Key>;\n        remove: (index: number) => void;\n        clear: () => void;\n        move: (index: number, newIndex: number) => void;\n        swap: (index: number, newIndex: number) => void;\n        append: (value: Parent[Key][keyof Parent[Key]]) => void;\n        values: NonNullable<Parent[Key]>;\n        setValues: (values: NonNullable<Parent[Key]>) => void;\n    }) => React.ReactNode;\n}) {\n    const arr = useArrayForm(props.form, props.name);\n    return <React.Fragment>{props.render?.(arr) ?? arr.values + \"\"}</React.Fragment>;\n}\n\n/**\n * Wrapper around useListener\n * Listen for changes on a form's field. Behaves like useState.\n * You shouldn't use this hook in large components, as it rerenders each time something changes. Use the wrapper <Listener /> instead.\n * @param form The form to listen on.\n * @param name The form's field to listen to.\n */\nexport function Listener<T, State, Error, Key extends keyof T>(props: {\n    form: FormState<T, State, Error>;\n    name: Key;\n    render?: (props: {\n        value: T[Key];\n        defaultValue: T[Key];\n        setValue: (value: T[Key]) => boolean;\n        dirty: DirtyMap<T>[Key];\n        error: ErrorMap<T, Error>[Key];\n        state: State;\n        form: FormState<T, State, Error>;\n    }) => React.ReactNode;\n}) {\n    const l = useListener(props.form, props.name);\n    return <React.Fragment>{props.render?.(l) ?? l.value + \"\"}</React.Fragment>;\n}\n\n/**\n * Wrapper around useAnyListener.\n * Listens for any change on this form. Behaves like useState.\n * You shouldn't use this hook in large components, as it rerenders each time something changes. Use the wrapper <AnyListener /> instead.\n * @param form The form to listen to.\n * @param onlyOnSetValues True if you only want to listen for changes that are set using setValues. (used for arrays)\n */\nexport function AnyListener<T, State, Error>(props: { form: FormState<T, State, Error>; onlyOnSetValues?: boolean; render?: (props: FormState<T, State, Error>) => React.ReactNode }) {\n    const l = useAnyListener(props.form, props.onlyOnSetValues);\n    return <React.Fragment>{props.render?.(l) ?? l.values + \"\"}</React.Fragment>;\n}\n\n/**\n * Wrapper around useChildForm\n * Creates a child form for another root or child form. You must use this for object and array (see useArrayForm) fields.\n * This hook doesn't cause a rerender.\n * @param parentForm The parent form.\n * @param name The parent's field to create a child form for.\n */\nexport function ChildForm<Parent, ParentState, ParentError, Key extends keyof Parent>(props: {\n    form: FormState<Parent, ParentState, ParentError>; // Use the parent prop instead of the form prop when using ChildForm.\n    name: Key;\n    render?: (props: ChildFormState<Parent, ParentState, ParentError, Key>) => React.ReactNode;\n}) {\n    const childForm = useChildForm(props.form, props.name);\n    let form = useAnyListener(childForm, true);\n    if (form.empty) return null;\n    return <React.Fragment>{props.render?.(childForm)}</React.Fragment>;\n}\n","import React, { HTMLAttributes } from \"react\";\nimport { FormState } from \"../form\";\nimport { useListener } from \"../hooks\";\n\nexport type FormErrorProps<T, Error, Key extends keyof T> = Omit<HTMLAttributes<HTMLParagraphElement>, \"name\" | \"form\"> & {\n    form: FormState<T, any, Error>;\n    name: Key;\n};\n\nexport function FormError<T, Error, Key extends keyof T>({ form, name, ...rest }: FormErrorProps<T, Error, Key>) {\n    const { error } = useListener(form, name);\n    if (!error) return null;\n    return <p {...rest}>{error + \"\"}</p>;\n}\n","import React, { SelectHTMLAttributes } from \"react\";\nimport { DefaultState, FormState } from \"../form\";\nimport { DEFAULT_DIRTY_CLASS, DEFAULT_ERROR_CLASS, getClassName } from \"./FormInput\";\nimport { useListener } from \"../hooks\";\n\nexport type FormSelectProps<T, State, Error> = Omit<SelectHTMLAttributes<HTMLSelectElement>, \"form\" | \"name\"> & {\n    form: FormState<T, State, Error>;\n    name: keyof T;\n    errorClassName?: string;\n    errorStyle?: React.CSSProperties;\n    dirtyClassName?: string;\n    dirtyStyle?: React.CSSProperties;\n    disableOnSubmitting?: boolean;\n    hideWhenNull?: boolean;\n};\n\nexport function FormSelect<T, State extends DefaultState, Error>({\n    form,\n    name,\n    errorClassName,\n    errorStyle,\n    dirtyClassName,\n    dirtyStyle,\n    disableOnSubmitting,\n    hideWhenNull,\n    children,\n    className,\n    style,\n    ...rest\n}: FormSelectProps<T, State, Error>) {\n    const { value, setValue, state, dirty, error } = useListener(form, name);\n    if (hideWhenNull && (value === null || value === undefined)) return null;\n    return (\n        <select\n            style={{\n                ...style,\n                ...(dirty && dirtyStyle),\n                ...(error && errorStyle)\n            }}\n            className={getClassName(className, dirty && (dirtyClassName ?? DEFAULT_DIRTY_CLASS), error && (errorClassName ?? DEFAULT_ERROR_CLASS))}\n            disabled={(disableOnSubmitting ?? true) && state.isSubmitting}\n            value={value as any}\n            onChange={(ev) => {\n                if (rest.multiple) setValue(Array.from(ev.target.selectedOptions).map((e) => e.value) as any);\n                else setValue(ev.target.value as any);\n            }}\n            {...rest}\n        >\n            {children}\n        </select>\n    );\n}\n","import React, { TextareaHTMLAttributes } from \"react\";\nimport { DefaultState, FormState } from \"../form\";\nimport { DEFAULT_DIRTY_CLASS, DEFAULT_ERROR_CLASS, getClassName } from \"./FormInput\";\nimport { useListener } from \"../hooks\";\n\nexport type FormTextAreaProps<T, State, Error> = Omit<TextareaHTMLAttributes<HTMLTextAreaElement>, \"form\" | \"name\"> & {\n    form: FormState<T, State, Error>;\n    name: keyof T;\n    errorClassName?: string;\n    errorStyle?: React.CSSProperties;\n    dirtyClassName?: string;\n    dirtyStyle?: React.CSSProperties;\n    disableOnSubmitting?: boolean;\n    hideWhenNull?: boolean;\n};\n\nexport function FormTextArea<T, State extends DefaultState, Error>({\n    form,\n    name,\n    errorClassName,\n    errorStyle,\n    dirtyClassName,\n    dirtyStyle,\n    disableOnSubmitting,\n    children,\n    className,\n    hideWhenNull,\n    style,\n    ...rest\n}: FormTextAreaProps<T, State, Error>) {\n    const { value, setValue, state, dirty, error } = useListener(form, name);\n    if (hideWhenNull && (value === null || value === undefined)) return null;\n    return (\n        <textarea\n            style={{\n                ...style,\n                ...(dirty && dirtyStyle),\n                ...(error && errorStyle)\n            }}\n            className={getClassName(className, dirty && (dirtyClassName ?? DEFAULT_DIRTY_CLASS), error && (errorClassName ?? DEFAULT_ERROR_CLASS))}\n            disabled={(disableOnSubmitting ?? true) && state.isSubmitting}\n            value={value as any}\n            onChange={(ev) => setValue(ev.target.value as any)}\n            {...rest}\n        >\n            {children}\n        </textarea>\n    );\n}\n","import React, { useRef } from \"react\";\n\nexport function VisualRender(props: { children: React.ReactNode }) {\n    let ref = useRef<HTMLDivElement>(null);\n    let timeoutRef = useRef<number | null>(null);\n\n    if (ref.current) {\n        ref.current.className = \"\";\n        if (timeoutRef.current) clearTimeout(timeoutRef.current);\n        timeoutRef.current = window.setTimeout(() => {\n            ref.current && (ref.current.className = \"blink\");\n        }, 100);\n    }\n\n    return <div ref={ref}>{props.children}</div>;\n}\n","import React, { useState } from \"react\";\nimport { AnyListener, ArrayForm, FormError, FormState, FormInput, FormSelect, useAnyListener, useChildForm, useForm, Listener, FormTextArea, ChildForm } from \"typed-react-form\";\nimport { VisualRender } from \"./VisualRender\";\n\ninterface ExampleFormData {\n    id: number;\n    name: string;\n    description: string;\n    author: User | null;\n    public: boolean;\n    date: number;\n    dateObject: Date;\n    language: \"en\" | \"nl\" | \"fr\";\n    tags: string[];\n    todos: Todo[];\n}\n\ninterface Todo {\n    message: string;\n    priority: \"low\" | \"normal\" | \"high\";\n}\n\ninterface User {\n    name: string;\n    age: number;\n}\n\nexport default function App() {\n    return (\n        <div>\n            <div style={{ padding: \"2em\", background: \"#333\", color: \"white\" }}>\n                <h1>\n                    Example form created using{\" \"}\n                    <a style={{ color: \"#3793ee\" }} href=\"https://github.com/CodeStix/typed-react-form\">\n                        typed-react-form\n                    </a>\n                </h1>\n                <p>\n                    The <strong style={{ color: \"red\" }}>red flash</strong> indicates which parts of the form are being rerendered. The{\" \"}\n                    <strong style={{ outline: \"3px solid gray\" }}>gray outline</strong> indicates that a field is dirty (modified) and the{\" \"}\n                    <strong style={{ outline: \"3px solid red\" }}>red outline</strong> indicates an error.\n                </p>\n                <p>\n                    Every part of this form's{\" \"}\n                    <a style={{ color: \"#3793ee\" }} href=\"https://github.com/CodeStix/typed-react-form/blob/master/example/src/App.tsx\">\n                        source code\n                    </a>{\" \"}\n                    is type-checked.\n                </p>\n            </div>\n            <Form />\n        </div>\n    );\n}\n\nconst initialValues: ExampleFormData = {\n    id: Math.ceil(Math.random() * 100000),\n    name: \"My todo list\",\n    description: \"this is a testing form\",\n    author: null,\n    public: true,\n    date: new Date().getTime(),\n    dateObject: new Date(),\n    tags: [\"test\"],\n    language: \"en\",\n    todos: [{ message: \"Fix this 0\", priority: \"normal\" }]\n};\n\nexport function Form() {\n    const form = useForm(\n        initialValues, // <- Default values, may change\n        { isSubmitting: false }, // <- Global form state, which can contain custom fields (e.g. loading)\n        validateTodoList, // <- Validator\n        true // <- Validate on change\n    );\n\n    return (\n        <form\n            onSubmit={async (ev) => {\n                ev.preventDefault();\n\n                form.validate(); // Validate manually when validateOnChange is disabled.\n                if (form.error) return; // Do not submit if errors\n\n                form.setState({ isSubmitting: true }); // Set the form state (updates every component listening for state updates)\n\n                await new Promise((res) => setTimeout(res, 1000)); // Fake fetch\n\n                form.setState({ isSubmitting: false }); // Set the form state (updates every component listening for state updates)\n                form.setDefaultValues(form.values); // Set new default values\n            }}\n        >\n            <div style={{ display: \"grid\", gridTemplateColumns: \"60% 40%\", gridTemplateRows: \"100%\", gap: \"2em\", margin: \"2em\" }}>\n                <VisualRender>\n                    <h3>\n                        Id <small>number</small>\n                    </h3>\n                    <FormInput type=\"number\" form={form} name=\"id\" />\n                    <hr />\n                    <h3>\n                        Name <small>string</small>\n                    </h3>\n                    <FormInput form={form} name=\"name\" />\n                    <FormError form={form} name=\"name\" />\n                    <hr />\n                    <h3>\n                        Public? <small>boolean</small>\n                    </h3>\n                    <p>Using radio buttons</p>\n                    <FormInput type=\"radio\" form={form} name=\"public\" value={false} /> no\n                    <FormInput type=\"radio\" form={form} name=\"public\" value={true} /> yes\n                    <p>Using checkbox</p>\n                    <FormInput type=\"checkbox\" form={form} name=\"public\" />\n                    <hr />\n                    <h3>\n                        Language <small>enum</small>\n                    </h3>\n                    <p>Using select</p>\n                    <FormSelect form={form} name=\"language\">\n                        <option value=\"en\">English</option>\n                        <option value=\"nl\">Dutch</option>\n                        <option value=\"fr\">French</option>\n                    </FormSelect>\n                    <p>Using radio buttons</p>\n                    <FormInput type=\"radio\" form={form} name=\"language\" value=\"en\" /> English\n                    <FormInput type=\"radio\" form={form} name=\"language\" value=\"nl\" /> Dutch\n                    <FormInput type=\"radio\" form={form} name=\"language\" value=\"fr\" /> French\n                    <hr />\n                    <h3>\n                        Todo's <small>dynamic array</small>\n                    </h3>\n                    {/* Use ArrayForm (wrapper around useArrayForm) to create dynamic forms */}\n                    <ArrayForm\n                        form={form}\n                        name=\"todos\"\n                        render={(\n                            { form, swap, remove, append } // <- Make sure to use the newly passed form (otherwise type checking will not work!)\n                        ) => (\n                            <VisualRender>\n                                <ul>\n                                    {form.values.map((\n                                        _,\n                                        i // You should use other key than index\n                                    ) => (\n                                        <TodoItem onMoveTop={() => swap(i, 0)} onRemove={() => remove(i)} key={i} parent={form} index={i} />\n                                    ))}\n                                </ul>\n                                <button\n                                    type=\"button\"\n                                    onClick={() =>\n                                        append({\n                                            message: \"\",\n                                            priority: \"normal\"\n                                        })\n                                    }\n                                >\n                                    Add item\n                                </button>\n                                {/* <button\n                                    type=\"button\"\n                                    onClick={() => {\n                                        setValues([\n                                            ...values,\n                                            ...Array(50)\n                                                .fill(0)\n                                                .map((_, i) => ({\n                                                    message: \"Fix this \" + i,\n                                                    priority: \"normal\" as \"normal\" // Wut\n                                                }))\n                                        ]);\n                                    }}\n                                >\n                                    Add 50 items\n                                </button> */}\n                            </VisualRender>\n                        )}\n                    />\n                    <hr />\n                    <h3>\n                        Date <small>timestamp number</small>\n                    </h3>\n                    <FormInput type=\"date\" form={form} name=\"date\" dateAsNumber />\n                    <hr />\n                    <h3>\n                        Date <small>date object</small>\n                    </h3>\n                    <FormInput type=\"date\" form={form} name=\"dateObject\" />\n                    <hr />\n                    <h3>\n                        Tags <small>string array</small>\n                    </h3>\n                    <p>\n                        Using select with <code>multiple=true</code>\n                    </p>\n                    <FormSelect form={form} name=\"tags\" multiple>\n                        <option value=\"test\">Test</option>\n                        <option value=\"fun\">Fun</option>\n                        <option value=\"school\">School</option>\n                    </FormSelect>\n                    <p>Using checkboxes</p>\n                    <label>\n                        <FormInput form={form} name=\"tags\" type=\"checkbox\" value=\"test\" />\n                        Test\n                    </label>\n                    <label>\n                        <FormInput form={form} name=\"tags\" type=\"checkbox\" value=\"fun\" />\n                        Fun\n                    </label>\n                    <label>\n                        <FormInput form={form} name=\"tags\" type=\"checkbox\" value=\"school\" />\n                        School\n                    </label>\n                    <hr />\n                    <h3>\n                        Description <small>string</small>\n                    </h3>\n                    <p>\n                        Using <code>FormTextArea</code>\n                    </p>\n                    <FormTextArea form={form} name=\"description\" rows={5} cols={50} />\n                    <p>\n                        Using <code>Listener</code> around <code>textarea</code>\n                    </p>\n                    <Listener form={form} name=\"description\" render={({ value, setValue }) => <textarea rows={5} cols={50} value={value} onChange={(ev) => setValue(ev.target.value)}></textarea>} />\n                    <hr />\n                    <h3>\n                        Author <small>string</small>\n                    </h3>\n                    <p>Togglable object field</p>\n                    <FormInput form={form} name=\"author\" type=\"checkbox\" setNullOnUncheck value={{ name: \"\", age: 0 }} />\n                    <ChildForm\n                        form={form}\n                        name=\"author\"\n                        render={(form) => (\n                            <VisualRender>\n                                <FormInput form={form} name=\"name\" />\n                                <FormInput form={form} name=\"age\" type=\"number\" />\n                            </VisualRender>\n                        )}\n                    />\n                </VisualRender>\n                <div style={{ position: \"sticky\", top: \"0\", height: \"500px\" }}>\n                    <h2>Output</h2>\n                    <FormValues form={form} />\n\n                    {/* Disable buttons when form is submitting or when nothing has changed, the AnyListener wrapper is required */}\n                    <AnyListener\n                        form={form}\n                        render={({ state, dirty }) => (\n                            <div style={{ margin: \"0.5em 0\" }}>\n                                <button style={{ fontSize: \"1.3em\" }} disabled={state.isSubmitting || !dirty}>\n                                    Submit\n                                </button>\n                                <button style={{ fontSize: \"1.3em\" }} disabled={state.isSubmitting || !dirty} type=\"button\" onClick={() => form.resetAll()}>\n                                    Reset\n                                </button>\n                            </div>\n                        )}\n                    />\n\n                    <div>\n                        <button style={{ fontSize: \"1.3em\" }} type=\"button\" onClick={() => form.validate()}>\n                            Validate\n                        </button>\n                        <label>\n                            <code>validateOnChange</code>\n                            <input type=\"checkbox\" defaultChecked={form.validateOnChange} onChange={(e) => (form.validateOnChange = e.target.checked)} />\n                        </label>\n                    </div>\n                </div>\n            </div>\n        </form>\n    );\n}\n\nfunction TodoItem(props: { parent: FormState<Todo[]>; index: number; onMoveTop: () => void; onRemove: () => void }) {\n    // Use a child form, each layer in the object is a seperate form: TodoList (useForm) -> Todo[] (useArrayForm) -> Todo (useChildForm)\n    const form = useChildForm(props.parent, props.index);\n\n    return (\n        <li\n            style={{\n                padding: \"0.5em\"\n            }}\n        >\n            <VisualRender>\n                <FormInput form={form} name=\"message\" />\n                <FormSelect form={form} name=\"priority\">\n                    <option value=\"low\">Low</option>\n                    <option value=\"normal\">Normal</option>\n                    <option value=\"high\">High</option>\n                </FormSelect>\n                <button type=\"button\" onClick={props.onMoveTop}>\n                    Go to top\n                </button>\n                <button type=\"button\" onClick={props.onRemove}>\n                    Remove\n                </button>\n            </VisualRender>\n        </li>\n    );\n}\n\n/**\n *  Shows a JSON representation of a form\n */\nfunction FormValues<T>(props: { form: FormState<T> }) {\n    const form = useAnyListener(props.form);\n    const [show, setShow] = useState({ values: true, defaultValues: false, errorMap: true, dirtyMap: true, state: false });\n    return (\n        <VisualRender>\n            <div style={{ background: \"#0001\", overflow: \"hidden\", padding: \"1em\", borderRadius: \"1em\" }}>\n                <p>\n                    <strong style={{ color: form.dirty ? \"blue\" : undefined }}>{form.dirty ? \"Modified\" : \"Unmodified\"}</strong>\n                </p>\n                <p>\n                    <strong style={{ color: form.error ? \"red\" : undefined }}>{form.error ? \"Has error\" : \"No errors\"}</strong>\n                </p>\n\n                <div>\n                    <strong>Show: </strong>\n                    <label>\n                        <input type=\"checkbox\" checked={show.values} onChange={(ev) => setShow({ ...show, values: ev.target.checked })} />\n                        <code>values</code>\n                    </label>\n                    <label>\n                        <input type=\"checkbox\" checked={show.defaultValues} onChange={(ev) => setShow({ ...show, defaultValues: ev.target.checked })} />\n                        <code>defaultValues</code>\n                    </label>\n                    <label>\n                        <input type=\"checkbox\" checked={show.errorMap} onChange={(ev) => setShow({ ...show, errorMap: ev.target.checked })} />\n                        <code>errorMap</code>\n                    </label>\n                    <label>\n                        <input type=\"checkbox\" checked={show.dirtyMap} onChange={(ev) => setShow({ ...show, dirtyMap: ev.target.checked })} />\n                        <code>dirtyMap</code>\n                    </label>\n                    <label>\n                        <input type=\"checkbox\" checked={show.state} onChange={(ev) => setShow({ ...show, state: ev.target.checked })} />\n                        <code>state</code>\n                    </label>\n                </div>\n\n                {show.values && <pre>values = {JSON.stringify(form.values, null, 2)}</pre>}\n                {show.defaultValues && <pre>defaultValues = {JSON.stringify(form.defaultValues, null, 2)}</pre>}\n                {show.errorMap && <pre>errorMap = {JSON.stringify(form.errorMap, null, 2)}</pre>}\n                {show.dirtyMap && <pre>dirtyMap = {JSON.stringify(form.dirtyMap, null, 2)}</pre>}\n                {show.state && <pre>state = {JSON.stringify(form.state, null, 2)}</pre>}\n            </div>\n        </VisualRender>\n    );\n}\n\n// You should use a validation library (yup, class-validator) instead of this mess...\nfunction validateTodoList(values: ExampleFormData) {\n    let todoErrors = values.todos.reduce((prev, val, index) => {\n        if (val.message.length < 5) {\n            prev[index] = { message: \"Todo message should be longer!\" };\n        }\n        return prev;\n    }, [] as any[]);\n    return {\n        // author: values.author.length < 3 ? \"Author name is too short.\" : undefined,\n        name: values.name.length < 3 ? \"Title is too short.\" : undefined,\n        todos: todoErrors.length > 0 ? todoErrors : undefined\n    };\n}\n","import \"./index.css\";\n\nimport React from \"react\";\nimport ReactDOM from \"react-dom\";\nimport App from \"./App\";\n\nReactDOM.render(<App />, document.getElementById(\"root\"));\n"],"sourceRoot":""}