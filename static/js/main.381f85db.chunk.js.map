{"version":3,"sources":["../../src/form.ts","../../src/hooks.ts","../../src/Components.tsx","VisualRender.tsx","App.tsx","index.tsx"],"names":["memberCopy","value","Array","Error","FormState","validateOnChange","formId","childMap","dirtyMap","errorMap","listeners","anyListeners","counter","this","setValueInternal","valueMap","isDefault","dirty","key","notifyChild","child","updateParentValues","validate","setValue","notifyParent","fireAny","defaultValues","values","setValues","newKeys","Object","localKeys","mostKeys","i","setDefaultValues","validator","console","setError","error","updateParentErrors","setErrors","errors","resetAll","reset","setState","c","updateParentState","listen","setters","id","listenAny","ignore","ignoreAny","fireListeners","a","l","fireAnyListeners","al","ChildFormState","parent","useChildForm","parentForm","name","useRef","useEffect","useListener","form","setRender","useState","e","defaultValue","state","useAnyListener","onlyOnSetValues","useArrayListener","remove","newValues","move","to","newArr","target","increment","k","swap","index","newIndex","clear","append","props","React","arr","defaultState","VisualRender","ref","timeoutRef","current","className","clearTimeout","window","setTimeout","children","Input","rest","disabled","isSubmitting","placeholder","style","background","padding","fontSize","outline","onChange","ev","fontWeight","color","App","author","todos","fill","map","_","message","priority","useForm","validateTodoList","onSubmit","preventDefault","Promise","res","margin","href","TodoItem","onMoveTop","onRemove","type","onClick","Date","getTime","defaultChecked","checked","FormValues","border","JSON","stringify","todoErrors","reduce","prev","val","length","undefined","ReactDOM","render","document","getElementById"],"mappings":"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","file":"static/js/main.381f85db.chunk.js","sourcesContent":["export type ListenerCallback = (setValuesWasUsed: boolean) => void;\nexport type ListenerMap = { [T in string]?: ListenerCallback };\nexport type Validator<T, Error> = (values: T) => ErrorMap<T, Error>;\n\nexport type ChildFormMap<T, State, Error> = {\n    [Key in keyof T]?: ChildFormState<T, State, Error, Key>;\n};\n\nexport type DirtyMap<T> = {\n    [Key in keyof T]?: boolean;\n};\n\ntype ObjectOrArray = {\n    [key: string]: any;\n    [key: number]: any;\n};\n\nexport type ErrorType<T, Error> = T extends ObjectOrArray ? ErrorMap<T, Error> : Error;\n\nexport type ErrorMap<T, Error> = {\n    [Key in keyof T]?: ErrorType<T[Key], Error>;\n};\n\nexport type DefaultError = string;\nexport type DefaultState = { isSubmitting: boolean };\n\nexport function memberCopy<T>(value: T): T {\n    if (Array.isArray(value)) {\n        return [...value] as any;\n    } else if (typeof value === \"object\") {\n        return { ...value };\n    } else {\n        throw new Error(\"Can only memberCopy() arrays and objects.\");\n    }\n}\n\nexport class FormState<T, State = DefaultState, Error = DefaultError> {\n    /**\n     * The id of this form, for debugging purposes.\n     */\n    public readonly formId = ++FormState.formCounter;\n\n    /**\n     * The form's validator.\n     */\n    public validator?: Validator<T, Error>;\n\n    /**\n     * Should the form validate on each value change?\n     */\n    public validateOnChange: boolean;\n\n    /**\n     * The values on this form. Use setValues() to set these.\n     */\n    public readonly values: T;\n\n    /**\n     * The default values on this form. Use setValues(..., true) to set these.\n     */\n    public readonly defaultValues: T;\n\n    /**\n     * The dictionary that maps object fields to child forms.\n     */\n    public readonly childMap: ChildFormMap<T, State, Error> = {};\n\n    /**\n     * The dictionary that contains dirty states for each field.\n     */\n    public readonly dirtyMap: DirtyMap<T> = {};\n\n    /**\n     * The dictionary that contains errors for each field.\n     */\n    public readonly errorMap: ErrorMap<T, Error> = {};\n\n    private _state: State;\n    private listeners: { [Key in keyof T]?: ListenerMap } = {};\n    private anyListeners: ListenerMap = {};\n    private counter = 0;\n    private static formCounter = 0;\n\n    public constructor(values: T, defaultValues: T, defaultState: State, validator?: Validator<T, Error>, validateOnChange = true) {\n        this.values = memberCopy(values);\n        this.defaultValues = memberCopy(defaultValues);\n        this._state = memberCopy(defaultState);\n        this.validator = validator;\n        this.validateOnChange = validateOnChange;\n    }\n\n    /**\n     * Gets the state of the current form.\n     */\n    public get state() {\n        return this._state;\n    }\n\n    /**\n     * Is this form modified?\n     */\n    public get dirty() {\n        return Object.keys(this.dirtyMap).some((e) => this.dirtyMap[e]);\n    }\n\n    /**\n     * Does this form contain any error?\n     */\n    public get error() {\n        return Object.keys(this.errorMap).some((e) => this.errorMap[e]);\n    }\n\n    /**\n     * Sets a value the advanced way.\n     * @param key The field to set.\n     * @param value The value to set in the field.\n     * @param dirty Is this field dirty? Leave undefined to not set any dirty value. (dirty value can always be overridden by child forms)\n     * @param validate Should the form validate after value set? This does not override `validateOnChange`.\n     * @param isDefault Is this the default value for the said field?\n     * @param notifyChild Should this form notify any child form about the change?\n     * @param notifyParent Should this form notify any parent form about the change?\n     * @param fireAny Fire all `anyListeners` after field is set? You should not touch this. (will be false for bulk sets, they will call fireAnyListeners() after every field is set)\n     */\n    public setValueInternal<Key extends keyof T>(\n        key: Key,\n        value: T[Key] | undefined,\n        dirty: boolean | undefined,\n        validate: boolean,\n        isDefault: boolean,\n        notifyChild: boolean,\n        notifyParent: boolean,\n        fireAny: boolean\n    ) {\n        let valueMap = isDefault ? this.defaultValues : this.values;\n        if (value === undefined) {\n            if (Array.isArray(valueMap)) valueMap.splice(key as number, 1);\n            else delete valueMap[key];\n        } else {\n            valueMap[key] = value;\n        }\n\n        if (dirty !== undefined) this.dirtyMap[key] = dirty;\n\n        if (notifyChild && value !== undefined) {\n            let child = this.childMap[key];\n            if (child) {\n                child.setValues(value, true, isDefault, true, false);\n                this.dirtyMap[key] = child.dirty;\n            }\n        }\n\n        this.fireListeners(key, false);\n        if (fireAny) {\n            // Will be false when using setValues, he will call fireAnyListeners and notifyParentValues itself\n            if (notifyParent) this.updateParentValues(isDefault); // Will call setValueInternal on parent\n            this.fireAnyListeners(false);\n        }\n\n        if (validate && this.validateOnChange && this.validator) this.validate();\n    }\n\n    /**\n     * Set a value on this form.\n     * @param key The field to set.\n     * @param value The field's new value.\n     * @param validate Should the form validate?\n     * @param isDefault Is this the default value?\n     * @param notifyChild Should this form notify the child form about this change?\n     * @param notifyParent Should this form notify the parent form about this change?\n     * @param fireAny Fire all `anyListeners` after field is set? You should not touch this. (will be false for bulk sets, they will call fireAnyListeners() after every field is set)\n     */\n    public setValue<Key extends keyof T>(\n        key: Key,\n        value: T[Key] | undefined,\n        validate: boolean = true,\n        isDefault: boolean = false,\n        notifyChild: boolean = true,\n        notifyParent: boolean = true,\n        fireAny: boolean = true\n    ) {\n        if (typeof value === \"object\") {\n            // Do not compare objects, child form should mark dirty\n            this.setValueInternal(key, value, undefined, validate, isDefault, notifyChild, notifyParent, fireAny);\n        } else {\n            // Calculate and compare value types, determine dirty?\n            if ((isDefault && this.defaultValues[key] === value) || (!isDefault && this.values[key] === value)) return false;\n            this.setValueInternal(key, value, isDefault ? value !== this.values[key] : value !== this.defaultValues[key], validate, isDefault, notifyChild, notifyParent, fireAny);\n        }\n        return true;\n    }\n\n    /**\n     * Set all values on this form.\n     * @param values The new values to set on this form.\n     * @param validate Validate? Does not override `validateOnChange`.\n     * @param isDefault Are these values the default values for this form?\n     * @param notifyChild Should this form notify the child form about this change?\n     * @param notifyParent Should this form notify the parent form about this change?\n     */\n    public setValues(values: T, validate: boolean = true, isDefault: boolean = false, notifyChild: boolean = true, notifyParent: boolean = true) {\n        // Copy the values to the local form object\n        let newKeys = Object.keys(isDefault ? this.defaultValues : this.values);\n        let localKeys = Object.keys(values);\n        let mostKeys = newKeys.length > localKeys.length ? newKeys : localKeys;\n        for (let i = 0; i < mostKeys.length; i++) {\n            let key = mostKeys[i] as keyof T;\n            this.setValue(\n                key,\n                values[key],\n                false, // Will validate after all values are copied\n                isDefault,\n                notifyChild,\n                notifyParent,\n                false // Will call fireAnyListener after all values are copied, see 3 lines down\n            );\n        }\n        if (notifyParent) this.updateParentValues(isDefault);\n        this.fireAnyListeners(true);\n\n        if (validate && this.validateOnChange && this.validator) this.validate();\n    }\n\n    /**\n     * Set default values for this form. (Convenience wrapper around `setValues()`)\n     * @param values The new default values to set on this form.\n     * @param validate Validate?\n     * @param notifyChild Should this form notify the child form about this change?\n     * @param notifyParent Should this form notify the parent form about this change?\n     */\n    public setDefaultValues(values: T, validate: boolean = true, notifyChild: boolean = true, notifyParent: boolean = true) {\n        this.setValues(values, validate, true, notifyChild, notifyParent);\n    }\n\n    /**\n     * Force validation on this field. Required when `validateOnChange` is disabled.\n     */\n    public validate() {\n        if (!this.validator) {\n            console.warn(\"validate() was called on a form which does not have a validator set.\");\n            return;\n        }\n        this.setErrors(this.validator(this.values));\n    }\n\n    /**\n     * Sets an error on this form\n     * @param key The field to set an error on.\n     * @param error The error.\n     * @param notifyChild Should this form notify the child form about this change?\n     * @param notifyParent Should this form notify the parent form about this change?\n     * @param fireAny\n     */\n    public setError<Key extends keyof T>(key: Key, error: ErrorType<T[Key], Error> | undefined, notifyChild: boolean = true, notifyParent: boolean = true, fireAny: boolean = true) {\n        if (this.errorMap[key] === error) return;\n\n        if (!error) delete this.errorMap[key];\n        else this.errorMap[key] = error;\n\n        if (notifyChild) this.childMap[key]?.setErrors((error ?? {}) as any);\n        this.fireListeners(key, false);\n        if (fireAny) {\n            if (notifyParent) this.updateParentErrors(); // Will call setError on parent\n            this.fireAnyListeners(false);\n        }\n    }\n\n    /**\n     * Sets all the errors on this form.\n     * @param errors The new errors for this form. Use {} to clear errors. **The format of this error object must follow the same structure of the values object, but each value is replaced by its error.**\n     * @param notifyChild Should this form notify the child form about this change?\n     * @param notifyParent Should this form notify the parent form about this change?\n     */\n    public setErrors(errors: ErrorMap<T, Error>, notifyChild: boolean = true, notifyParent: boolean = true) {\n        let localKeys = Object.keys(this.errorMap);\n        let newKeys = Object.keys(errors);\n        let mostKeys = newKeys.length > localKeys.length ? newKeys : localKeys;\n        for (let i = 0; i < mostKeys.length; i++) {\n            let key = mostKeys[i] as keyof T;\n            this.setError(\n                key,\n                errors[key] as any,\n                notifyChild,\n                notifyParent,\n                false // Will call fireAnyListener by itself, see 3 lines down\n            );\n        }\n        if (notifyParent) this.updateParentErrors();\n        this.fireAnyListeners(false);\n    }\n\n    /**\n     * Reset this form's values to the default values.\n     */\n    public resetAll() {\n        this.setValues(this.defaultValues);\n    }\n\n    /**\n     * Reset a form's field to its default value.\n     * @param key The field to reset.\n     */\n    public reset(key: keyof T) {\n        this.setValue(key, this.defaultValues[key]);\n    }\n\n    /**\n     * Sets the state for this form, and also on child and parent forms by default.\n     * @param state The new form state.\n     * @param notifyChild Set the state on the child too?\n     * @param notifyParent Set the state on the parent too?\n     */\n    public setState(state: State, notifyChild: boolean = true, notifyParent: boolean = true) {\n        this._state = state;\n\n        let c = Object.keys(this.values);\n        if (notifyChild) c.forEach((e) => this.childMap[e]?.setState(state, notifyChild, notifyParent));\n\n        c.forEach((e) => this.fireListeners(e as keyof T, false));\n        if (notifyParent) this.updateParentState();\n        this.fireAnyListeners(false);\n    }\n\n    /**\n     * Listen for changes on a field, will trigger when value, defaultValue, dirty and error changes for a field. Make sure you pass its return value back to `ignore()` after you are done listening.\n     * @param key The field to listen to.\n     * @param listener Change callback.\n     */\n    public listen(key: keyof T, listener: ListenerCallback): string {\n        if (!this.listeners) this.listeners = {};\n        let setters = this.listeners[key];\n        if (!setters) {\n            setters = {};\n            this.listeners[key] = setters;\n        }\n        let id = \"\" + this.counter++;\n        setters[id] = listener;\n        return id;\n    }\n\n    /**\n     * Listen for any change on this form. Make sure you pass its return value back to `ignoreAny()` after you are done listening.\n     * @param listener Change callback.\n     */\n    public listenAny(listener: ListenerCallback) {\n        if (!this.anyListeners) this.anyListeners = {};\n        let id = \"\" + this.counter++;\n        this.anyListeners[id] = listener;\n        return id;\n    }\n\n    /**\n     * Ignore changes on a field.\n     * @param key The field to ignore.\n     * @param id The callback to ignore.\n     */\n    public ignore(key: keyof T, id: string) {\n        if (!this.listeners) return;\n        let setters = this.listeners[key];\n        if (!setters) {\n            console.warn(\"Ignore was called for no reason\", key, id);\n            return;\n        }\n        delete setters[id];\n    }\n\n    /**\n     * Ignore changes on this form.\n     * @param id The callback to ignore.\n     */\n    public ignoreAny(id: string) {\n        if (!this.anyListeners) return;\n        delete this.anyListeners[id];\n    }\n\n    protected fireListeners(key: keyof T, setValuesWasUsed: boolean) {\n        let a = this.listeners[key];\n        if (a) {\n            let l = Object.keys(a!);\n            l.forEach((e) => a![e]!(setValuesWasUsed));\n        }\n    }\n\n    protected fireAnyListeners(setValuesWasUsed: boolean) {\n        let al = Object.keys(this.anyListeners);\n        al.forEach((e) => this.anyListeners[e]!(setValuesWasUsed));\n    }\n\n    protected updateParentValues(_isDefault: boolean) {\n        // Not implemented for root form, as it does not have a parent\n    }\n\n    protected updateParentErrors() {\n        // Not implemented for root form, as it does not have a parent\n    }\n\n    protected updateParentState() {\n        // Not implemented for root form, as it does not have a parent\n    }\n}\n\nexport class ChildFormState<Parent, ParentState, ParentError, Key extends keyof Parent> extends FormState<Parent[Key], ParentState, ParentError> {\n    public name: Key;\n    public readonly parent: FormState<Parent, ParentState, ParentError>;\n\n    public constructor(parent: FormState<Parent, ParentState, ParentError>, name: Key) {\n        super(parent.values[name] ?? ({} as any), parent.defaultValues[name] ?? ({} as any), parent.state);\n        this.parent = parent;\n        this.name = name;\n    }\n\n    protected updateParentValues(isDefault: boolean) {\n        this.parent.setValueInternal(this.name, isDefault ? memberCopy(this.defaultValues) : memberCopy(this.values), this.dirty, true, isDefault, false, true, true);\n    }\n\n    protected updateParentErrors() {\n        this.parent.setError(this.name, this.error ? (memberCopy(this.errorMap) as any) : undefined, false, true);\n    }\n\n    protected updateParentState() {\n        this.parent.setState(memberCopy(this.state), false, true);\n    }\n}\n","import { useRef, useEffect, useState } from \"react\";\nimport { DefaultState, DefaultError, FormState, ChildFormState, Validator } from \"./form\";\n\n/**\n * Creates a new root form.\n * This hook doesn't cause a rerender.\n * @param defaultValues The default values for this form.\n * @param defaultState The default state for this form. Form state contains custom global states, example: isSubmitting, isLoading ...\n * @param validator The validator to use, optional.\n * @param validateOnChange Validate on change?\n */\nexport function useForm<T, State = DefaultState, Error = DefaultError>(defaultValues: T, defaultState: State, validator?: Validator<T, Error>, validateOnChange = true) {\n    let c = useRef<FormState<T, State, Error> | null>(null);\n\n    if (!c.current) {\n        c.current = new FormState(defaultValues, defaultValues, defaultState, validator, validateOnChange);\n    }\n\n    useEffect(() => {\n        c.current!.setValues(defaultValues, true, true);\n    }, [defaultValues]);\n\n    return c.current;\n}\n\n/**\n * Creates a nested form for another root or nested form. You must use this for object and array (see useArrayListener) field.\n * This hook doesn't cause a rerender.\n * @param parentForm The parent form.\n * @param name The parent's field to create a child form for.\n */\nexport function useChildForm<T, State, Error, Key extends keyof T>(parentForm: FormState<T, State, Error>, name: Key) {\n    let c = useRef<ChildFormState<T, State, Error, Key> | null>(null);\n    if (!c.current) {\n        c.current = new ChildFormState(parentForm, name);\n    }\n\n    useEffect(() => {\n        // Update parent and child form\n        parentForm.childMap[name] = c.current!;\n        c.current!.name = name;\n\n        // Set new default values, without notifying parent and children\n        c.current!.setValues(parentForm.defaultValues[name] ?? ({} as any), true, true, false, false);\n        // Then, set new values, and notify parent and children\n        c.current!.setValues(parentForm.values[name] ?? ({} as any), true, false, true, true);\n\n        return () => {\n            // Could already be overriden (useEffect ordering)\n            if (parentForm.childMap[name] === c.current!) {\n                delete parentForm.childMap[name];\n                delete parentForm.errorMap[name];\n                delete parentForm.dirtyMap[name];\n            }\n        };\n    }, [parentForm, name]);\n\n    return c.current;\n}\n\n/**\n * Listen for changes on a form's field. Behaves like useState.\n * You shouldn't use this hook in large components, as it rerenders each time something changes. Use the wrapper <Listener /> instead.\n * @param form The form to listen on.\n * @param name The form's field to listen to.\n */\nexport function useListener<T, State, Error, Key extends keyof T>(form: FormState<T, State, Error>, name: Key) {\n    const [, setRender] = useState(0);\n\n    useEffect(() => {\n        let id = form.listen(name, () => setRender((e) => e + 1));\n        return () => form.ignore(name, id);\n    }, [form, name]);\n\n    return {\n        value: form.values[name],\n        defaultValue: form.defaultValues[name],\n        setValue: (value: T[Key]) => form.setValue(name, value),\n        dirty: form.dirtyMap[name],\n        error: form.errorMap[name],\n        state: form.state,\n        form\n    };\n}\n\n/**\n * Listens for any change on this form. Behaves like useState.\n * You shouldn't use this hook in large components, as it rerenders each time something changes. Use the wrapper <AnyListener /> instead.\n * @param form The form to listen to.\n * @param onlyOnSetValues True if you only want to listen for changes that are set using setValues. (used for arrays)\n */\nexport function useAnyListener<T, State, Error>(form: FormState<T, State, Error>, onlyOnSetValues = false) {\n    const [, setRender] = useState(0);\n\n    useEffect(() => {\n        let id = form.listenAny((all) => {\n            if (!onlyOnSetValues || all) setRender((e) => e + 1);\n        });\n        return () => form.ignoreAny(id);\n    }, [form]);\n\n    return form;\n}\n\n/**\n * This is a wrapper around useChildForm, with useful functions to manipulate arrays.\n * This hook does cause a rerender, but only if the whole array changes.\n * @param parent The parent form.\n * @param name The parent's field to create a child form for.\n */\nexport function useArrayListener<Parent, ParentState, ParentError, Key extends keyof Parent>(parent: FormState<Parent, ParentState, ParentError>, name: Key) {\n    const form = useChildForm<Parent, ParentState, ParentError, Key>(parent, name);\n    useAnyListener(form, true);\n\n    function append(value: Parent[Key][keyof Parent[Key]]) {\n        form.setValues([...(form.values as any), value] as any);\n    }\n\n    function remove(index: number) {\n        let newValues = [...(form.values as any)];\n        newValues.splice(index, 1);\n        form.setValues(newValues as any);\n    }\n\n    function clear() {\n        form.setValues([] as any);\n    }\n\n    function move(from: number, to: number) {\n        if (to === from) return;\n        let newArr = [...(form.values as any)];\n        var target = newArr[from];\n        var increment = to < from ? -1 : 1;\n        for (var k = from; k !== to; k += increment) {\n            newArr[k] = newArr[k + increment];\n        }\n        newArr[to] = target;\n        form.setValues(newArr as any);\n    }\n\n    function swap(index: number, newIndex: number) {\n        if (index === newIndex) {\n            return;\n        }\n        let values = [...(form.values as any)];\n        [values[index], values[newIndex]] = [values[newIndex], values[index]];\n        form.setValues(values as any);\n    }\n\n    return {\n        remove,\n        move,\n        swap,\n        clear,\n        append,\n        form: form,\n        values: form.values,\n        setValues: form.setValues\n    };\n}\n","import React from \"react\";\nimport { DirtyMap, ErrorMap, FormState } from \"./form\";\nimport { useArrayListener, useListener, useAnyListener, useChildForm } from \"./hooks\";\n\n/**\n * Wrapper around useArrayListener (which is a wrapper around useChildForm).\n * Exports useful functions to manipulate arrays.\n * This hook does cause a rerender, but only if the whole array changes.\n * @param parent The parent form.\n * @param name The parent's field to create a child form for.\n */\nexport function ArrayListener<Parent, ParentState, ParentError, Key extends keyof Parent>(props: {\n    parent: FormState<Parent, ParentState, ParentError>;\n    name: Key;\n    children: (props: {\n        form: FormState<Parent[Key], ParentState, ParentError>;\n        remove: (index: number) => void;\n        clear: () => void;\n        move: (index: number, newIndex: number) => void;\n        swap: (index: number, newIndex: number) => void;\n        append: (value: Parent[Key][keyof Parent[Key]]) => void;\n        values: Parent[Key];\n        setValues: (values: Parent[Key]) => void;\n    }) => React.ReactNode;\n}) {\n    const arr = useArrayListener(props.parent, props.name);\n    return <React.Fragment>{props.children(arr)}</React.Fragment>;\n}\n\n/**\n * Wrapper around useListener\n * Listen for changes on a form's field. Behaves like useState.\n * You shouldn't use this hook in large components, as it rerenders each time something changes. Use the wrapper <Listener /> instead.\n * @param form The form to listen on.\n * @param name The form's field to listen to.\n */\nexport function Listener<T, State, Error, Key extends keyof T>(props: {\n    form: FormState<T, State, Error>;\n    name: Key;\n    children: (props: {\n        value: T[Key];\n        defaultValue: T[Key];\n        setValue: (value: T[Key]) => boolean;\n        dirty: DirtyMap<T>[Key];\n        error: ErrorMap<T, Error>[Key];\n        state: State;\n        form: FormState<T, State, Error>;\n    }) => React.ReactNode;\n}) {\n    const l = useListener(props.form, props.name);\n    return <React.Fragment>{props.children(l)}</React.Fragment>;\n}\n\n/**\n * Wrapper around useAnyListener.\n * Listens for any change on this form. Behaves like useState.\n * You shouldn't use this hook in large components, as it rerenders each time something changes. Use the wrapper <AnyListener /> instead.\n * @param form The form to listen to.\n * @param onlyOnSetValues True if you only want to listen for changes that are set using setValues. (used for arrays)\n */\nexport function AnyListener<T, State, Error>(props: { form: FormState<T, State, Error>; onlyOnSetValues?: boolean; children: (props: FormState<T, State, Error>) => React.ReactNode }) {\n    const l = useAnyListener(props.form, props.onlyOnSetValues);\n    return <React.Fragment>{props.children(l)}</React.Fragment>;\n}\n\n/**\n * Wrapper around useChildForm\n * Creates a nested form for another root or nested form. You must use this for object and array (see useArrayListener) field.\n * This hook doesn't cause a rerender.\n * @param parentForm The parent form.\n * @param name The parent's field to create a child form for.\n */\nexport function ChildForm<Parent, ParentState, ParentError, Key extends keyof Parent>(props: {\n    parent: FormState<Parent, ParentState, ParentError>;\n    name: Key;\n    children: (props: FormState<Parent[Key], ParentState, ParentError>) => React.ReactNode;\n}) {\n    const arr = useChildForm(props.parent, props.name);\n    return <React.Fragment>{props.children(arr)}</React.Fragment>;\n}\n","import React, { useRef } from \"react\";\n\nexport function VisualRender(props: { children: React.ReactNode }) {\n    let ref = useRef<HTMLDivElement>(null);\n    let timeoutRef = useRef<number | null>(null);\n\n    if (ref.current) {\n        ref.current.className = \"\";\n        if (timeoutRef.current) clearTimeout(timeoutRef.current);\n        timeoutRef.current = window.setTimeout(() => {\n            ref.current && (ref.current.className = \"blink\");\n        }, 100);\n    }\n\n    return <div ref={ref}>{props.children}</div>;\n}\n","import React, { InputHTMLAttributes, useState } from \"react\";\nimport { AnyListener, ArrayListener, FormState, useAnyListener, useChildForm, useForm, useListener } from \"typed-react-form\";\nimport { VisualRender } from \"./VisualRender\";\n\ninterface TodoList {\n    name: string;\n    author: string;\n    todos: Todo[];\n}\n\ninterface Todo {\n    id: number;\n    message: string;\n    priority: \"low\" | \"normal\" | \"high\";\n}\n\n/**\n * A custom input that can be reused everywhere when using useForm\n */\nfunction Input<T>({\n    form,\n    name,\n    ...rest\n}: {\n    form: FormState<T, { isSubmitting: boolean }>;\n    name: keyof T;\n} & Omit<InputHTMLAttributes<HTMLInputElement>, \"name\" | \"form\">) {\n    const { value, dirty, defaultValue, error, state } = useListener(form, name);\n\n    return (\n        <VisualRender>\n            <input\n                disabled={state.isSubmitting}\n                placeholder={defaultValue as any}\n                style={{\n                    background: dirty ? \"#eee\" : \"#fff\",\n                    padding: \"0.3em\",\n                    fontSize: \"inherit\",\n                    outline: error ? \"4px solid #f306\" : \"none\"\n                }}\n                value={value as any}\n                onChange={(ev) => form.setValue(name, ev.target.value as any)}\n                {...rest}\n            />\n            {error && (\n                <span\n                    style={{\n                        padding: \"0.3em\",\n                        fontWeight: \"bold\",\n                        color: \"red\"\n                    }}\n                >\n                    {error}\n                </span>\n            )}\n        </VisualRender>\n    );\n}\n\nexport default function App() {\n    const [values, setValues] = useState<TodoList>({\n        author: \"codestix\",\n        name: \"My todo list\",\n        todos: Array(3)\n            .fill(0)\n            .map((_, i) => ({\n                message: \"Fix this \" + i,\n                priority: \"normal\",\n                id: i\n            }))\n    });\n\n    const form = useForm(\n        values, // <- Default values, can change\n        { isSubmitting: false }, // <- Global form state, which can contain custom fields (e.g. loading)\n        validateTodoList, // <- Validator\n        true // <- Validate on change\n    );\n\n    return (\n        <form\n            onSubmit={async (ev) => {\n                ev.preventDefault();\n\n                form.validate(); // Validate manually when validateOnChange is disabled.\n                if (form.error) return; // Do not submit if errors\n\n                form.setState({ isSubmitting: true }); // Set the form state (updates every component listening for state updates)\n\n                await new Promise((res) => setTimeout(res, 1000)); // Fake fetch\n\n                form.setState({ isSubmitting: false }); // Set the form state (updates every component listening for state updates)\n\n                setValues({ ...form.values }); // Set new default values, (form.setValues(..., true, true) is also possible instead of useState/useForm combo!)\n            }}\n            style={{ padding: \"1em\", margin: \"1em\" }}\n        >\n            <VisualRender>\n                <h1>\n                    Form created using <a href=\"https://github.com/CodeStix/typed-react-form\">typed-react-form</a>\n                </h1>\n                <p>\n                    The red flash indicates which parts of the form are being rerendered. Browse the source code <a href=\"https://github.com/CodeStix/typed-react-form/tree/master/example/src\">here</a>\n                    .\n                </p>\n                <hr />\n                <h2>Todo list</h2>\n                <p>Name</p>\n                {/* The name field is type checked, try to name it something else that does not exist on interface TodoList */}\n                <Input form={form} name=\"name\" />\n                <p>Author</p>\n                <Input form={form} name=\"author\" />\n                <p>Todo's</p>\n\n                {/* Use ArrayForm (wrapper around useArrayForm) to create dynamic forms */}\n                <ArrayListener parent={form} name=\"todos\">\n                    {(\n                        { form, swap, remove, append } // <- Make sure to use the newly passed form (otherwise type checking will not work!)\n                    ) => (\n                        <VisualRender>\n                            <ul style={{ padding: \"0\" }}>\n                                {form.values.map((e, i) => (\n                                    <TodoItem onMoveTop={() => swap(i, 0)} onRemove={() => remove(i)} key={e.id} parent={form} index={i} />\n                                ))}\n                            </ul>\n                            <button\n                                style={{ margin: \"0 0 1em 0\" }}\n                                type=\"button\"\n                                onClick={() =>\n                                    append({\n                                        message: \"\",\n                                        priority: \"normal\",\n                                        id: new Date().getTime()\n                                    })\n                                }\n                            >\n                                Add item\n                            </button>\n                        </VisualRender>\n                    )}\n                </ArrayListener>\n                <div style={{ background: \"#eee\" }}>\n                    <AnyListener form={form}>\n                        {({ state, dirty }) => (\n                            <>\n                                {/* Disable buttons when form is submitting or when nothing has changed, the AnyListener wrapper is required */}\n                                <button style={{ fontSize: \"1.3em\", margin: \"0.5em 0\" }} disabled={state.isSubmitting || !dirty}>\n                                    Submit\n                                </button>\n                                <button style={{ fontSize: \"1.3em\", margin: \"0.5em 0\" }} disabled={state.isSubmitting || !dirty} type=\"button\" onClick={() => form.resetAll()}>\n                                    Reset\n                                </button>\n                            </>\n                        )}\n                    </AnyListener>\n                    <div>\n                        <button style={{ fontSize: \"1.3em\" }} type=\"button\" onClick={() => form.validate()}>\n                            Validate\n                        </button>\n                        <label>\n                            <code>validateOnChange</code>\n                            <input type=\"checkbox\" defaultChecked={form.validateOnChange} onChange={(e) => (form.validateOnChange = e.target.checked)} />\n                        </label>\n                    </div>\n                </div>\n\n                <h3>Output</h3>\n                <FormValues form={form} />\n            </VisualRender>\n        </form>\n    );\n}\n\nfunction TodoItem(props: { parent: FormState<Todo[], { isSubmitting: boolean }>; index: number; onMoveTop: () => void; onRemove: () => void }) {\n    // Use a child form, each layer in the object is a seperate form: TodoList (useForm) -> Todo[] (useArrayForm) -> Todo (useChildForm)\n    const form = useChildForm(props.parent, props.index);\n\n    return (\n        <li\n            style={{\n                padding: \"1em\",\n                margin: \"1em\",\n                border: \"1px solid #0003\"\n            }}\n        >\n            <VisualRender>\n                <Input form={form} name=\"message\" />\n                <button type=\"button\" onClick={props.onMoveTop}>\n                    Go to top\n                </button>\n                <button type=\"button\" onClick={props.onRemove}>\n                    Remove\n                </button>\n            </VisualRender>\n        </li>\n    );\n}\n\n/**\n *  Shows a JSON representation of a form\n */\nfunction FormValues<T>(props: { form: FormState<T> }) {\n    const form = useAnyListener(props.form);\n    return (\n        <VisualRender>\n            <div style={{ background: \"#0001\" }}>\n                <p>\n                    {/* <em>{val.formId}</em> */}\n                    {form.dirty && <strong style={{ color: \"blue\" }}>DIRTY</strong>}\n                    {form.error && <strong style={{ color: \"red\" }}>ERROR</strong>}\n                </p>\n                <pre>{JSON.stringify(form.values, null, 2)}</pre>\n                {/* <pre>{JSON.stringify(form.defaultValues)}</pre> */}\n                <pre>{JSON.stringify(form.errorMap, null, 2)}</pre>\n                <pre>{JSON.stringify(form.dirtyMap, null, 2)}</pre>\n                {/* <pre>{JSON.stringify(form.state, null, 2)}</pre> */}\n            </div>\n        </VisualRender>\n    );\n}\n\n// You should use a validation library (yup, class-validator) instead of this mess...\nfunction validateTodoList(values: TodoList) {\n    let todoErrors = values.todos.reduce((prev, val, index) => {\n        if (val.message.length < 5) {\n            prev[index] = { message: \"Todo message should be longer!\" };\n        }\n        return prev;\n    }, [] as any[]);\n    return {\n        author: values.author.length < 3 ? \"Author name is too short.\" : undefined,\n        name: values.name.length < 3 ? \"Title is too short.\" : undefined,\n        todos: todoErrors.length > 0 ? todoErrors : undefined\n    };\n}\n","import \"./index.css\";\n\nimport React from \"react\";\nimport ReactDOM from \"react-dom\";\nimport App from \"./App\";\n\nReactDOM.render(<App />, document.getElementById(\"root\"));\n"],"sourceRoot":""}