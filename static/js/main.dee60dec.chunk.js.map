{"version":3,"sources":["../../src/form.ts","../../src/hooks.ts","../../src/elements/FormInput.tsx","../../node_modules/babel-plugin-transform-async-to-promises/helpers.js","../../src/yup.ts","../../src/Components.tsx","../../src/elements/FormError.tsx","../../src/elements/FormSelect.tsx","../../src/elements/FormTextArea.tsx","VisualRender.tsx","App.tsx","index.tsx"],"names":["memberCopy","value","Array","Error","comparePrimitiveObject","a","b","ak","Object","bk","lk","i","k","av","bv","FormState","formId","childMap","dirtyMap","errorMap","listeners","anyListeners","counter","this","setValueInternal","validate","isDefault","notifyChild","notifyParent","fireAny","valueMap","child","updateParentValues","fireAnyListeners","setValue","dirty","values","defaultValues","console","key","setValues","newKeys","localKeys","mostKeys","setDefaultValues","setErrors","e","setError","error","updateParentErrors","changed","errors","resetAll","reset","setState","c","updateParentState","listen","setters","id","listenAny","ignore","ignoreAny","fireListeners","l","al","ChildFormState","parent","useChildForm","parentForm","name","useRef","useEffect","useListener","form","setRender","useState","defaultValue","state","useAnyListener","append","remove","newValues","clear","move","to","newArr","target","increment","swap","index","newIndex","useArrayForm","oldLength","val","getClassName","args","Symbol","iterator","asyncIterator","yupErrorToErrorMap","errorTransformer","obj","err","pathSegments","o","j","oo","props","React","childForm","oldThruthly","thruthly","FormError","rest","FormInput","style","className","disableOnSubmitting","dateAsNumber","errorClassName","errorStyle","dirtyClassName","dirtyStyle","setUndefinedOnUncheck","setNullOnUncheck","hideWhenNull","inputValue","currentValue","useMemo","inValue","inChecked","n","ni","parseInt","isNaN","d","Date","disabled","checked","onChange","newValue","ev","newChecked","parseFloat","arr","FormSelect","children","FormTextArea","defaultState","validator","validateOnMount","validateOnChange","isSubmitting","yupSchema","options","messageTransformer","body","recover","result","then","ex","VisualRender","ref","timeoutRef","current","clearTimeout","window","setTimeout","App","padding","background","color","href","outline","Form","initialValues","Math","ceil","random","description","author","public","date","getTime","dateObject","tags","language","todos","message","priority","useForm","validateTodoList","onSubmit","preventDefault","Promise","res","display","gridTemplateColumns","gridTemplateRows","gap","margin","type","render","map","_","TodoItem","onMoveTop","onRemove","onClick","fill","multiple","rows","cols","age","position","top","height","FormValues","fontSize","defaultChecked","show","setShow","overflow","borderRadius","undefined","JSON","stringify","todoErrors","reduce","prev","length","ReactDOM","document","getElementById"],"mappings":"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","file":"static/js/main.dee60dec.chunk.js","sourcesContent":["export type ListenerCallback = () => void;\nexport type ListenerMap = { [T in string]?: ListenerCallback };\nexport type Validator<T, Error> = (values: T) => ErrorMap<T, Error> | Promise<ErrorMap<T, Error>>;\n\nexport type ChildFormMap<T, State, Error> = {\n    [Key in keyof T]?: ChildFormState<T, State, Error, Key>;\n};\n\nexport type DirtyMap<T> = {\n    [Key in keyof T]?: boolean;\n};\n\ntype ObjectOrArray = {\n    [key: string]: any;\n    [key: number]: any;\n};\n\nexport type ErrorType<T, Error> = T extends ObjectOrArray ? ErrorMap<T, Error> | Error : Error;\n\nexport type ErrorMap<T, Error> = {\n    [Key in keyof T]?: ErrorType<T[Key], Error>;\n};\n\nexport type DefaultError = string;\nexport type DefaultState = { isSubmitting: boolean };\n\nexport function memberCopy<T>(value: T): T {\n    if (Array.isArray(value)) {\n        return [...value] as any;\n    } else if (typeof value === \"object\") {\n        return { ...value };\n    } else {\n        throw new Error(\"Can only memberCopy() arrays and objects.\");\n    }\n}\n\n/**\n * Compares 2 objects that only contain primitive fields (no object fields)\n * @returns true when different, false when 'equal', undefined when an object field was found.\n */\nexport function comparePrimitiveObject<T>(a: T, b: T): boolean | undefined {\n    // Compare null and undefined\n    if (!a || !b) return a === b;\n    let ak = Object.keys(a),\n        bk = Object.keys(b);\n    let lk = ak.length > bk.length ? ak : bk;\n    for (let i = 0; i < lk.length; i++) {\n        let k = lk[i];\n        let av = a[k],\n            bv = b[k];\n        if ((typeof av === \"object\" && av !== null) || (typeof bv === \"object\" && bv !== null)) return undefined;\n        if (av !== bv) return true;\n    }\n    return false;\n}\n\nexport class FormState<T, State = DefaultState, Error = DefaultError> {\n    /**\n     * The id of this form, for debugging purposes.\n     */\n    public readonly formId = ++FormState.formCounter;\n\n    /**\n     * The form's validator.\n     */\n    public validator?: Validator<T, Error>;\n\n    /**\n     * Should the form validate on each value change?\n     */\n    public validateOnChange: boolean;\n    public validateOnMount: boolean;\n\n    /**\n     * The values on this form. Use setValues() to set these.\n     */\n    public readonly values: T;\n\n    /**\n     * The default values on this form. Use setDefaultValues(...) to set these.\n     */\n    public readonly defaultValues: T;\n\n    /**\n     * The dictionary that maps object fields to child forms.\n     */\n    public readonly childMap: ChildFormMap<T, State, Error> = {};\n\n    /**\n     * The dictionary that contains dirty states for each field.\n     */\n    public readonly dirtyMap: DirtyMap<T> = {};\n\n    /**\n     * The dictionary that contains errors for each field.\n     */\n    public readonly errorMap: ErrorMap<T, Error> = {};\n\n    private _state: State;\n    private listeners: { [Key in keyof T]?: ListenerMap } = {};\n    private anyListeners: ListenerMap = {};\n    private counter = 0;\n    private static formCounter = 0;\n\n    public constructor(\n        values: T,\n        defaultValues: T,\n        defaultState: State,\n        validator: Validator<T, Error> | undefined,\n        validateOnMount: boolean,\n        validateOnChange: boolean\n    ) {\n        this.values = memberCopy(values);\n        this.defaultValues = memberCopy(defaultValues);\n        this._state = memberCopy(defaultState);\n        this.validator = validator;\n        this.validateOnMount = validateOnMount;\n        this.validateOnChange = validateOnChange;\n    }\n\n    /**\n     * Gets the state of the current form.\n     */\n    public get state() {\n        return this._state;\n    }\n\n    /**\n     * Is this form modified?\n     */\n    public get dirty() {\n        return Object.keys(this.dirtyMap).some((e) => this.dirtyMap[e]);\n    }\n\n    /**\n     * Does this form contain any error?\n     */\n    public get error() {\n        return Object.keys(this.errorMap).some((e) => this.errorMap[e]);\n    }\n\n    /**\n     * Is this form null/undefined or {}?\n     */\n    public get empty() {\n        return Object.keys(this.values).length === 0;\n    }\n\n    /**\n     * Sets a value the advanced way.\n     * @param key The field to set.\n     * @param value The value to set in the field.\n     * @param dirty Is this field dirty? Leave undefined to not set any dirty value. (can always be overridden by child forms)\n     * @param validate Should the form validate after value set? This does not override `validateOnChange`.\n     * @param isDefault Is this the default value for the said field?\n     * @param notifyChild Should this form notify any child form about the change?\n     * @param notifyParent Should this form notify any parent form about the change?\n     * @param setValuesWasUsed Fire all `anyListeners` after field is set? You should not touch this. (will be false for bulk sets, they will call fireAnyListeners() after every field is set)\n     */\n    public setValueInternal<Key extends keyof T>(\n        key: Key,\n        value: T[Key] | undefined,\n        dirty: boolean,\n        validate: boolean = true,\n        isDefault: boolean = false,\n        notifyChild: boolean = true,\n        notifyParent: boolean = true,\n        fireAny: boolean = true\n    ) {\n        let valueMap = isDefault ? this.defaultValues : this.values;\n        if (value === undefined) {\n            if (Array.isArray(valueMap)) valueMap.splice(key as number, 1);\n            else delete valueMap[key];\n        } else {\n            valueMap[key] = value;\n        }\n\n        this.dirtyMap[key] = dirty;\n\n        if (notifyChild) {\n            let child = this.childMap[key];\n            if (child && value !== undefined && value !== null) {\n                child.setValues(value!, true, isDefault, true, false);\n                this.dirtyMap[key] = child.dirty;\n            }\n        }\n\n        this.fireListeners(key);\n        if (notifyParent) this.updateParentValues(isDefault); // Will call setValueInternal on parent\n        if (fireAny) this.fireAnyListeners(); // Will be false when using setValues, he will call fireAnyListeners and notifyParentValues itself\n\n        if (validate && this.validateOnChange && this.validator) this.validate();\n    }\n\n    /**\n     * Set a value on this form.\n     * @param key The field to set.\n     * @param value The field's new value.\n     * @param validate Should the form validate?\n     * @param isDefault Is this the default value?\n     * @param notifyChild Should this form notify the child form about this change?\n     * @param notifyParent Should this form notify the parent form about this change?\n     * @param setValuesWasUsed Fire all `anyListeners` after field is set? You should not touch this. (will be false for bulk sets, they will call fireAnyListeners() after every field is set)\n     */\n    public setValue<Key extends keyof T>(\n        key: Key,\n        value: T[Key] | undefined,\n        validate: boolean = true,\n        isDefault: boolean = false,\n        notifyChild: boolean = true,\n        notifyParent: boolean = true,\n        fireAny: boolean = true\n    ) {\n        // value can contain the default value or normal value. (Determined by isDefault)\n        if (typeof value === \"object\" && value !== null) {\n            let dirty: boolean | undefined = false;\n            if (value instanceof Date) {\n                // Compare date objects\n                dirty = value?.getTime() !== (isDefault ? this.values[key] : (this.defaultValues[key] as any))?.getTime();\n            } else if (fireAny) {\n                // Compare primitive objects (objects containing only primitive fields), but only is setValues was not used (dirty value will be determined by child forms)\n                dirty = comparePrimitiveObject(value, isDefault ? this.values[key] : this.defaultValues[key]); // Is switched intentionally\n                if (dirty === undefined) {\n                    console.warn(\n                        \"Do not use setValue for object in object fields, use setValueInternal instead (dirty value can not be determined), \",\n                        key,\n                        value\n                    );\n                    dirty = true;\n                }\n            }\n\n            this.setValueInternal(key, value, dirty, validate, isDefault, notifyChild, notifyParent, fireAny);\n        } else {\n            // Compare value and existing value/defaultValue which determines dirty\n            let dirty = isDefault ? value !== this.values[key] : value !== this.defaultValues[key];\n\n            // Do not set if already set\n            if (((isDefault && this.defaultValues[key] === value) || (!isDefault && this.values[key] === value)) && this.dirtyMap[key] === dirty) {\n                return;\n            }\n\n            this.setValueInternal(key, value, dirty, validate, isDefault, notifyChild, notifyParent, fireAny);\n        }\n    }\n\n    /**\n     * Set all values on this form.\n     * @param values The new values to set on this form.\n     * @param validate Validate? Does not override `validateOnChange`.\n     * @param isDefault Are these values the default values for this form?\n     * @param notifyChild Should this form notify the child form about this change?\n     * @param notifyParent Should this form notify the parent form about this change?\n     */\n    public setValues(values: T, validate: boolean = true, isDefault: boolean = false, notifyChild: boolean = true, notifyParent: boolean = true) {\n        // Copy the values to the local form object\n        let newKeys = Object.keys(isDefault ? this.defaultValues : this.values);\n        let localKeys = Object.keys(values);\n        let mostKeys = newKeys.length > localKeys.length ? newKeys : localKeys;\n        for (let i = 0; i < mostKeys.length; i++) {\n            let key = mostKeys[i] as keyof T;\n            this.setValue(\n                key,\n                values[key],\n                false, // Will validate after all values are copied\n                isDefault,\n                notifyChild,\n                false, // Will call updateParentValues by itself after all values are copied, see 3 lines down\n                false // Will call fireAnyListener by itself after all values are copied, see 3 lines down\n            );\n        }\n        if (notifyParent) this.updateParentValues(isDefault);\n        this.fireAnyListeners();\n\n        if (validate && this.validateOnChange && this.validator) this.validate();\n    }\n\n    /**\n     * Set default values for this form. (Convenience wrapper around `setValues()`)\n     * @param values The new default values to set on this form.\n     * @param validate Validate?\n     * @param notifyChild Should this form notify the child form about this change?\n     * @param notifyParent Should this form notify the parent form about this change?\n     */\n    public setDefaultValues(values: T, validate: boolean = true, notifyChild: boolean = true, notifyParent: boolean = true) {\n        this.setValues(values, validate, true, notifyChild, notifyParent);\n    }\n\n    /**\n     * Force validation on this form. Required when `validateOnChange` is disabled.\n     */\n    public async validate() {\n        if (!this.validator) {\n            console.warn(\"validate() was called on a form which does not have a validator set.\");\n            return;\n        }\n        this.setErrors(await this.validator(this.values));\n    }\n\n    /**\n     * Sets an error on this form\n     * @param key The field to set an error on.\n     * @param error The error.\n     * @param notifyChild Should this form notify the child form about this change?\n     * @param notifyParent Should this form notify the parent form about this change?\n     * @param setValuesWasUsed\n     */\n    public setError<Key extends keyof T>(\n        key: Key,\n        error: ErrorType<T[Key], Error> | undefined,\n        notifyChild: boolean = true,\n        notifyParent: boolean = true,\n        fireAny: boolean = true\n    ) {\n        if (typeof error !== \"object\" && this.errorMap[key] === error) return false;\n\n        if (!error) delete this.errorMap[key];\n        else this.errorMap[key] = error;\n\n        if (notifyChild && this.childMap[key]) {\n            let changed = !this.childMap[key]!.setErrors((typeof error === \"object\" ? error ?? {} : {}) as any, true, false);\n            // Only return if the object changed, when a string error was given, this should not return\n            if (changed && typeof error === \"object\") return false;\n        }\n\n        this.fireListeners(key);\n        if (notifyParent) this.updateParentErrors(); // Will call setError on parent\n        if (fireAny) this.fireAnyListeners(); // When setValuesWasUsed, it will call fireAnyListener itself when all values were set\n        return true;\n    }\n\n    /**\n     * Sets all the errors on this form.\n     * @param errors The new errors for this form. Use {} to clear errors. **The format of this error object must follow the same structure of the values object, but each value is replaced by its error.**\n     * @param notifyChild Should this form notify the child form about this change?\n     * @param notifyParent Should this form notify the parent form about this change?\n     */\n    public setErrors(errors: ErrorMap<T, Error>, notifyChild: boolean = true, notifyParent: boolean = true) {\n        let localKeys = Object.keys(this.errorMap);\n        let newKeys = Object.keys(errors);\n        let mostKeys = newKeys.length > localKeys.length ? newKeys : localKeys;\n        let changed = false;\n        for (let i = 0; i < mostKeys.length; i++) {\n            let key = mostKeys[i] as keyof T;\n            changed =\n                changed ||\n                this.setError(\n                    key,\n                    errors[key] as any,\n                    notifyChild,\n                    false, // Will call updateParentErrors by itself after all values have been copied, see 3 lines down\n                    false // Will call fireAnyListener by itself after all values have been copied, see 3 lines down\n                );\n        }\n        if (!changed) return false;\n        if (notifyParent) this.updateParentErrors();\n        this.fireAnyListeners();\n        return true;\n    }\n\n    /**\n     * Reset this form's values to the default values.\n     * @param notifyChild Should this form notify the child form about this change?\n     * @param notifyParent Should this form notify the parent form about this change?\n     */\n    public resetAll(notifyChild: boolean = true, notifyParent: boolean = true) {\n        this.setValues(this.defaultValues, true, false, notifyChild, notifyParent);\n    }\n\n    /**\n     * Reset a form's field to its default value.\n     * @param key The field to reset.\n     * @param notifyChild Should this form notify the child form about this change?\n     * @param notifyParent Should this form notify the parent form about this change?\n     */\n    public reset(key: keyof T, notifyChild: boolean = true, notifyParent: boolean = true) {\n        this.setValue(key, this.defaultValues[key], true, false, notifyChild, notifyParent);\n    }\n\n    /**\n     * Sets the state for this form, and also on child and parent forms by default.\n     * @param newState The new form state.\n     * @param notifyChild Set the state on the child too?\n     * @param notifyParent Set the state on the parent too?\n     */\n    public setState(newState: State, notifyChild: boolean = true, notifyParent: boolean = true) {\n        this._state = newState;\n\n        let c = Object.keys(this.values);\n        if (notifyChild) c.forEach((e) => this.childMap[e]?.setState(newState, notifyChild, notifyParent));\n\n        c.forEach((e) => this.fireListeners(e as keyof T));\n        if (notifyParent) this.updateParentState();\n        this.fireAnyListeners();\n    }\n\n    /**\n     * Listen for changes on a field, will trigger when value, defaultValue, dirty and error changes for a field. Make sure you pass its return value back to `ignore()` after you are done listening.\n     * @param key The field to listen to.\n     * @param listener Change callback.\n     */\n    public listen(key: keyof T, listener: ListenerCallback): string {\n        if (!this.listeners) this.listeners = {};\n        let setters = this.listeners[key];\n        if (!setters) {\n            setters = {};\n            this.listeners[key] = setters;\n        }\n        let id = \"\" + this.counter++;\n        setters[id] = listener;\n        return id;\n    }\n\n    /**\n     * Listen for any change on this form. Make sure you pass its return value back to `ignoreAny()` after you are done listening.\n     * @param listener Change callback.\n     */\n    public listenAny(listener: ListenerCallback) {\n        if (!this.anyListeners) this.anyListeners = {};\n        let id = \"\" + this.counter++;\n        this.anyListeners[id] = listener;\n        return id;\n    }\n\n    /**\n     * Ignore changes on a field.\n     * @param key The field to ignore.\n     * @param id The callback to ignore.\n     */\n    public ignore(key: keyof T, id: string) {\n        if (!this.listeners) return;\n        let setters = this.listeners[key];\n        if (!setters) {\n            console.warn(\"Ignore was called for no reason\", key, id);\n            return;\n        }\n        delete setters[id];\n    }\n\n    /**\n     * Ignore changes on this form.\n     * @param id The callback to ignore.\n     */\n    public ignoreAny(id: string) {\n        if (!this.anyListeners) return;\n        delete this.anyListeners[id];\n    }\n\n    protected fireListeners(key: keyof T) {\n        let a = this.listeners[key];\n        if (a) {\n            let l = Object.keys(a!);\n            l.forEach((e) => a![e]!());\n        }\n    }\n\n    protected fireAnyListeners() {\n        let al = Object.keys(this.anyListeners);\n        al.forEach((e) => this.anyListeners[e]!());\n    }\n\n    protected updateParentValues(_isDefault: boolean) {\n        // Not implemented for root form, as it does not have a parent\n    }\n\n    protected updateParentErrors() {\n        // Not implemented for root form, as it does not have a parent\n    }\n\n    protected updateParentState() {\n        // Not implemented for root form, as it does not have a parent\n    }\n}\n\nexport class ChildFormState<Parent, ParentState, ParentError, Key extends keyof Parent> extends FormState<\n    NonNullable<Parent[Key]>,\n    ParentState,\n    ParentError\n> {\n    public name: Key;\n    public readonly parent: FormState<Parent, ParentState, ParentError>;\n\n    public constructor(parent: FormState<Parent, ParentState, ParentError>, name: Key) {\n        super(\n            parent.values[name] ?? ({} as any),\n            parent.defaultValues[name] ?? ({} as any),\n            parent.state,\n            undefined,\n            parent.validateOnMount,\n            parent.validateOnChange\n        );\n        this.parent = parent;\n        this.name = name;\n    }\n\n    protected updateParentValues(isDefault: boolean) {\n        this.parent.setValueInternal(\n            this.name,\n            isDefault ? memberCopy(this.defaultValues) : memberCopy(this.values),\n            this.dirty,\n            true,\n            isDefault,\n            false,\n            true,\n            true\n        );\n    }\n\n    protected updateParentErrors() {\n        this.parent.setError(this.name, this.error ? (memberCopy(this.errorMap) as any) : undefined, false, true);\n    }\n\n    protected updateParentState() {\n        this.parent.setState(memberCopy(this.state), false, true);\n    }\n}\n","import { useRef, useEffect, useState } from \"react\";\nimport { DefaultState, DefaultError, FormState, ChildFormState, Validator } from \"./form\";\n\n/**\n * Creates a new root form.\n * This hook doesn't cause a rerender.\n * @param defaultValues The default values for this form.\n * @param defaultState The default state for this form. Form state contains custom global states, example: isSubmitting, isLoading ...\n * @param validator The validator to use, optional.\n * @param validateOnChange Validate on change?\n */\nexport function useForm<T, State = DefaultState, Error = DefaultError>(\n    defaultValues: T,\n    defaultState: State = { isSubmitting: false } as any,\n    validator?: Validator<T, Error>,\n    validateOnMount = false,\n    validateOnChange = true\n) {\n    let c = useRef<FormState<T, State, Error> | null>(null);\n\n    if (!c.current) {\n        c.current = new FormState(defaultValues, defaultValues, defaultState, validator, validateOnMount, validateOnChange);\n    }\n\n    useEffect(() => {\n        c.current!.setValues(defaultValues, c.current!.validateOnMount, true);\n    }, [defaultValues]);\n\n    return c.current;\n}\n\n/**\n * Creates a nested form for another root or nested form. You must use this for object and array (see useArrayForm) field.\n * This hook doesn't cause a rerender.\n * @param parentForm The parent form.\n * @param name The parent's field to create a child form for.\n */\nexport function useChildForm<T, State, Error, Key extends keyof T>(parentForm: FormState<T, State, Error>, name: Key) {\n    let c = useRef<ChildFormState<T, State, Error, Key> | null>(null);\n    if (!c.current) {\n        c.current = new ChildFormState(parentForm, name);\n    }\n\n    useEffect(() => {\n        // Update parent and child form\n        parentForm.childMap[name] = c.current!;\n        c.current!.name = name;\n\n        // Set new default values, without notifying children\n        c.current!.setValues(parentForm.defaultValues[name] ?? ({} as any), false, true, false, false);\n        // Then, set new values and notify children\n        c.current!.setValues(parentForm.values[name] ?? ({} as any), c.current!.validateOnMount, false, true, false);\n\n        return () => {\n            // Could already be overriden (useEffect ordering)\n            if (parentForm.childMap[name] === c.current!) {\n                delete parentForm.childMap[name];\n                delete parentForm.errorMap[name];\n                delete parentForm.dirtyMap[name];\n            }\n        };\n    }, [parentForm, name]);\n\n    return c.current;\n}\n\n/**\n * Listen for changes on a form's field. Behaves like useState.\n * You shouldn't use this hook in large components, as it rerenders each time something changes. Use the wrapper <Listener /> instead.\n * @param form The form to listen on.\n * @param name The form's field to listen to.\n */\nexport function useListener<T, State, Error, Key extends keyof T>(form: FormState<T, State, Error>, name: Key) {\n    const [, setRender] = useState(0);\n\n    useEffect(() => {\n        let id = form.listen(name, () => {\n            setRender((e) => e + 1);\n        });\n        return () => form.ignore(name, id);\n    }, [form, name]);\n\n    return {\n        value: form.values[name],\n        defaultValue: form.defaultValues[name],\n        setValue: (value: T[Key]) => form.setValue(name, value),\n        dirty: form.dirtyMap[name],\n        error: form.errorMap[name],\n        state: form.state,\n        form\n    };\n}\n\n/**\n * Listens for any change on this form. Behaves like useState.\n * You shouldn't use this hook in large components, as it rerenders each time something changes. Use the wrapper <AnyListener /> instead.\n * @param form The form to listen to.\n */\nexport function useAnyListener<T, State, Error>(form: FormState<T, State, Error>) {\n    const [, setRender] = useState(0);\n\n    useEffect(() => {\n        let id = form.listenAny(() => {\n            setRender((e) => e + 1);\n        });\n        return () => form.ignoreAny(id);\n    }, [form]);\n\n    return form;\n}\n\nfunction append<T, Key extends keyof T>(this: FormState<T, any, any>, value: NonNullable<T[Key]>[keyof NonNullable<T[Key]>]) {\n    this.setValues([...(this.values as any), value] as any);\n}\n\nfunction remove(this: FormState<any, any, any>, index: number) {\n    let newValues = [...this.values];\n    newValues.splice(index, 1);\n    this.setValues(newValues);\n}\n\nfunction clear(this: FormState<any, any, any>) {\n    this.setValues([]);\n}\n\nfunction move(this: FormState<any, any, any>, from: number, to: number) {\n    if (to === from) return;\n    let newArr = [...this.values];\n    var target = newArr[from];\n    var increment = to < from ? -1 : 1;\n    for (var k = from; k !== to; k += increment) {\n        newArr[k] = newArr[k + increment];\n    }\n    newArr[to] = target;\n    this.setValues(newArr);\n}\n\nfunction swap(this: FormState<any, any, any>, index: number, newIndex: number) {\n    if (index === newIndex) {\n        return;\n    }\n    let values = [...this.values];\n    [values[index], values[newIndex]] = [values[newIndex], values[index]];\n    this.setValues(values);\n}\n\n/**\n * This is a wrapper around useChildForm, with useful functions to manipulate arrays.\n * This hook does cause a rerender, but only if the array size changes.\n * @param parentForm The parent form.\n * @param name The parent's field to create a child form for.\n */\nexport function useArrayForm<Parent, ParentState, ParentError, Key extends keyof Parent>(\n    parentForm: FormState<Parent, ParentState, ParentError>,\n    name: Key\n) {\n    const form = useChildForm<Parent, ParentState, ParentError, Key>(parentForm, name);\n    const oldLength = useRef(-1);\n    const [, setRender] = useState(0);\n\n    // Only rerender when array size changed\n    useEffect(() => {\n        let id = parentForm.listen(name, () => {\n            let val = parentForm.values[name] as any;\n            if (val.length !== oldLength.current) {\n                setRender((i) => i + 1);\n                oldLength.current = val.length;\n            }\n        });\n        return () => parentForm.ignore(name, id);\n    }, []);\n\n    return {\n        remove: remove.bind(form),\n        move: move.bind(form),\n        swap: swap.bind(form),\n        clear: clear.bind(form),\n        append: append.bind(form),\n        form: form,\n        values: form.values,\n        setValues: form.setValues.bind(form)\n    };\n}\n","import React, { useMemo } from \"react\";\nimport { InputHTMLAttributes } from \"react\";\nimport { DefaultState, FormState } from \"../form\";\nimport { useListener } from \"../hooks\";\n\ntype BaldInputProps = Omit<InputHTMLAttributes<HTMLInputElement>, \"name\" | \"form\" | \"value\">;\n\nexport const DEFAULT_DIRTY_CLASS = \"typed-form-dirty\";\nexport const DEFAULT_ERROR_CLASS = \"typed-form-error\";\n\nexport function getClassName(...args: any) {\n    return [...args].filter((e) => !!e).join(\" \");\n}\n\nexport type FormInputCheckMode = \"normal\" | \"setNull\" | \"setUndefined\";\n\nexport type FormInputProps<T, State, Error, Key extends keyof T, Value extends T[Key] | T[Key][keyof T[Key]]> = BaldInputProps & {\n    form: FormState<T, State, Error>;\n    name: Key;\n    value?: Value;\n    errorClassName?: string;\n    errorStyle?: React.CSSProperties;\n    dirtyClassName?: string;\n    dirtyStyle?: React.CSSProperties;\n    disableOnSubmitting?: boolean;\n    dateAsNumber?: boolean;\n    setNullOnUncheck?: boolean;\n    setUndefinedOnUncheck?: boolean;\n    hideWhenNull?: boolean;\n};\n\nexport function FormInput<T, State extends DefaultState, Error, Key extends keyof T, Value extends T[Key] | T[Key][keyof T[Key]]>({\n    form,\n    name,\n    style,\n    className,\n    disableOnSubmitting,\n    dateAsNumber,\n    errorClassName,\n    errorStyle,\n    dirtyClassName,\n    dirtyStyle,\n    setUndefinedOnUncheck,\n    setNullOnUncheck,\n    hideWhenNull,\n    value: inputValue,\n    checked: inputChecked,\n    ...rest\n}: FormInputProps<T, State, Error, Key, Value>) {\n    const { value: currentValue, error, dirty, state, setValue, defaultValue } = useListener(form, name);\n\n    let [inValue, inChecked] = useMemo(() => {\n        let inValue = undefined,\n            inChecked = undefined;\n        switch (rest.type) {\n            case \"number\": {\n                inValue = (currentValue ?? \"\") + \"\";\n                break;\n            }\n            case \"datetime-local\":\n            case \"date\": {\n                let n = currentValue as any;\n                if (typeof n === \"string\") {\n                    let ni = parseInt(n);\n                    if (!isNaN(ni)) n = ni;\n                }\n                let d = new Date(n);\n                if (d.getTime() === d.getTime()) {\n                    // Trick to check if date is valid: NaN === NaN returns false\n                    inValue = d?.toISOString().split(\"T\")[0] ?? \"\";\n                } else {\n                    inValue = \"\";\n                }\n                break;\n            }\n            case \"radio\": {\n                inChecked = currentValue === inputValue;\n                break;\n            }\n            case \"checkbox\": {\n                if (setNullOnUncheck) {\n                    inChecked = currentValue !== null;\n                } else if (setUndefinedOnUncheck) {\n                    inChecked = currentValue !== undefined;\n                } else if (inputValue !== undefined) {\n                    inChecked = (Array.isArray(currentValue) ? currentValue : []).includes(inputValue as never);\n                } else {\n                    inChecked = !!currentValue;\n                }\n                break;\n            }\n            default: {\n                inValue = (currentValue ?? \"\") + \"\";\n                break;\n            }\n        }\n        return [inValue, inChecked];\n    }, [rest.type, currentValue, inputValue]);\n\n    if (hideWhenNull && (currentValue === null || currentValue === undefined)) return null;\n\n    if ((setNullOnUncheck || setUndefinedOnUncheck) && rest.type !== \"checkbox\")\n        console.warn(\"setNullOnUncheck/setUndefinedOnUncheck only has an effect on checkboxes.\");\n\n    return (\n        <input\n            style={{\n                ...style,\n                ...(dirty && dirtyStyle),\n                ...(error && errorStyle)\n            }}\n            className={getClassName(className, dirty && (dirtyClassName ?? DEFAULT_DIRTY_CLASS), error && (errorClassName ?? DEFAULT_ERROR_CLASS))}\n            disabled={(disableOnSubmitting ?? true) && state.isSubmitting}\n            value={inValue}\n            checked={inChecked}\n            onChange={(ev) => {\n                let newValue = ev.target.value;\n                let newChecked = ev.target.checked;\n                switch (rest.type) {\n                    case \"number\": {\n                        setValue(parseFloat(newValue) as any);\n                        return;\n                    }\n                    case \"datetime-local\":\n                    case \"date\": {\n                        if (newValue) {\n                            let d = new Date(newValue);\n                            setValue((dateAsNumber ? d.getTime() : d) as any);\n                        } else {\n                            setValue(null as any);\n                        }\n                        return;\n                    }\n                    case \"radio\": {\n                        // Enum field\n                        if (newChecked) {\n                            setValue(inputValue as any);\n                        }\n                        return;\n                    }\n                    case \"checkbox\": {\n                        if (setNullOnUncheck || setUndefinedOnUncheck) {\n                            if (newChecked && inputValue === undefined && !defaultValue)\n                                console.warn(\n                                    \"Toggling checkbox using setNullOnUncheck got checked but a value to set was not found, please provide the value prop\"\n                                );\n                            setValue(\n                                newChecked ? (inputValue !== undefined ? inputValue : defaultValue) : ((setNullOnUncheck ? null : undefined) as any)\n                            );\n                        } else if (inputValue !== undefined) {\n                            // Primitive array field\n                            let arr = Array.isArray(currentValue) ? [...currentValue] : [];\n                            if (newChecked) arr.push(inputValue);\n                            else arr.splice(arr.indexOf(inputValue), 1);\n                            setValue(arr as any);\n                        } else {\n                            // Boolean field\n                            setValue(newChecked as any);\n                        }\n                        return;\n                    }\n                    default: {\n                        // String field\n                        setValue(newValue as any);\n                        return;\n                    }\n                }\n            }}\n            name={name as string}\n            {...rest}\n        />\n    );\n}\n","// A type of promise-like that resolves synchronously and supports only one observer\nexport const _Pact = /*#__PURE__*/(function() {\n\tfunction _Pact() {}\n\t_Pact.prototype.then = function(onFulfilled, onRejected) {\n\t\tconst result = new _Pact();\n\t\tconst state = this.s;\n\t\tif (state) {\n\t\t\tconst callback = state & 1 ? onFulfilled : onRejected;\n\t\t\tif (callback) {\n\t\t\t\ttry {\n\t\t\t\t\t_settle(result, 1, callback(this.v));\n\t\t\t\t} catch (e) {\n\t\t\t\t\t_settle(result, 2, e);\n\t\t\t\t}\n\t\t\t\treturn result;\n\t\t\t} else {\n\t\t\t\treturn this;\n\t\t\t}\n\t\t}\n\t\tthis.o = function(_this) {\n\t\t\ttry {\n\t\t\t\tconst value = _this.v;\n\t\t\t\tif (_this.s & 1) {\n\t\t\t\t\t_settle(result, 1, onFulfilled ? onFulfilled(value) : value);\n\t\t\t\t} else if (onRejected) {\n\t\t\t\t\t_settle(result, 1, onRejected(value));\n\t\t\t\t} else {\n\t\t\t\t\t_settle(result, 2, value);\n\t\t\t\t}\n\t\t\t} catch (e) {\n\t\t\t\t_settle(result, 2, e);\n\t\t\t}\n\t\t};\n\t\treturn result;\n\t}\n\treturn _Pact;\n})();\n\n// Settles a pact synchronously\nexport function _settle(pact, state, value) {\n\tif (!pact.s) {\n\t\tif (value instanceof _Pact) {\n\t\t\tif (value.s) {\n\t\t\t\tif (state & 1) {\n\t\t\t\t\tstate = value.s;\n\t\t\t\t}\n\t\t\t\tvalue = value.v;\n\t\t\t} else {\n\t\t\t\tvalue.o = _settle.bind(null, pact, state);\n\t\t\t\treturn;\n\t\t\t}\n\t\t}\n\t\tif (value && value.then) {\n\t\t\tvalue.then(_settle.bind(null, pact, state), _settle.bind(null, pact, 2));\n\t\t\treturn;\n\t\t}\n\t\tpact.s = state;\n\t\tpact.v = value;\n\t\tconst observer = pact.o;\n\t\tif (observer) {\n\t\t\tobserver(pact);\n\t\t}\n\t}\n}\n\nexport function _isSettledPact(thenable) {\n\treturn thenable instanceof _Pact && thenable.s & 1;\n}\n\n// Converts argument to a function that always returns a Promise\nexport function _async(f) {\n\treturn function() {\n\t\tfor (var args = [], i = 0; i < arguments.length; i++) {\n\t\t\targs[i] = arguments[i];\n\t\t}\n\t\ttry {\n\t\t\treturn Promise.resolve(f.apply(this, args));\n\t\t} catch(e) {\n\t\t\treturn Promise.reject(e);\n\t\t}\n\t}\n}\n\n// Awaits on a value that may or may not be a Promise (equivalent to the await keyword in ES2015, with continuations passed explicitly)\nexport function _await(value, then, direct) {\n\tif (direct) {\n\t\treturn then ? then(value) : value;\n\t}\n\tif (!value || !value.then) {\n\t\tvalue = Promise.resolve(value);\n\t}\n\treturn then ? value.then(then) : value;\n}\n\n// Awaits on a value that may or may not be a Promise, then ignores it\nexport function _awaitIgnored(value, direct) {\n\tif (!direct) {\n\t\treturn value && value.then ? value.then(_empty) : Promise.resolve();\n\t}\n}\n\n// Proceeds after a value has resolved, or proceeds immediately if the value is not thenable\nexport function _continue(value, then) {\n\treturn value && value.then ? value.then(then) : then(value);\n}\n\n// Proceeds after a value has resolved, or proceeds immediately if the value is not thenable\nexport function _continueIgnored(value) {\n\tif (value && value.then) {\n\t\treturn value.then(_empty);\n\t}\n}\n\n// Asynchronously iterate through an object that has a length property, passing the index as the first argument to the callback (even as the length property changes)\nexport function _forTo(array, body, check) {\n\tvar i = -1, pact, reject;\n\tfunction _cycle(result) {\n\t\ttry {\n\t\t\twhile (++i < array.length && (!check || !check())) {\n\t\t\t\tresult = body(i);\n\t\t\t\tif (result && result.then) {\n\t\t\t\t\tif (_isSettledPact(result)) {\n\t\t\t\t\t\tresult = result.v;\n\t\t\t\t\t} else {\n\t\t\t\t\t\tresult.then(_cycle, reject || (reject = _settle.bind(null, pact = new _Pact(), 2)));\n\t\t\t\t\t\treturn;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (pact) {\n\t\t\t\t_settle(pact, 1, result);\n\t\t\t} else {\n\t\t\t\tpact = result;\n\t\t\t}\n\t\t} catch (e) {\n\t\t\t_settle(pact || (pact = new _Pact()), 2, e);\n\t\t}\n\t}\n\t_cycle();\n\treturn pact;\n}\n\n// Asynchronously iterate through an object's properties (including properties inherited from the prototype)\n// Uses a snapshot of the object's properties\nexport function _forIn(target, body, check) {\n\tvar keys = [];\n\tfor (var key in target) {\n\t\tkeys.push(key);\n\t}\n\treturn _forTo(keys, function(i) { return body(keys[i]); }, check);\n}\n\n// Asynchronously iterate through an object's own properties (excluding properties inherited from the prototype)\n// Uses a snapshot of the object's properties\nexport function _forOwn(target, body, check) {\n\tvar keys = [];\n\tfor (var key in target) {\n\t\tif (Object.prototype.hasOwnProperty.call(target, key)) {\n\t\t\tkeys.push(key);\n\t\t}\n\t}\n\treturn _forTo(keys, function(i) { return body(keys[i]); }, check);\n}\n\nexport const _iteratorSymbol = /*#__PURE__*/ typeof Symbol !== \"undefined\" ? (Symbol.iterator || (Symbol.iterator = Symbol(\"Symbol.iterator\"))) : \"@@iterator\";\n\n// Asynchronously iterate through an object's values\n// Uses for...of if the runtime supports it, otherwise iterates until length on a copy\nexport function _forOf(target, body, check) {\n\tif (typeof target[_iteratorSymbol] === \"function\") {\n\t\tvar iterator = target[_iteratorSymbol](), step, pact, reject;\n\t\tfunction _cycle(result) {\n\t\t\ttry {\n\t\t\t\twhile (!(step = iterator.next()).done && (!check || !check())) {\n\t\t\t\t\tresult = body(step.value);\n\t\t\t\t\tif (result && result.then) {\n\t\t\t\t\t\tif (_isSettledPact(result)) {\n\t\t\t\t\t\t\tresult = result.v;\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tresult.then(_cycle, reject || (reject = _settle.bind(null, pact = new _Pact(), 2)));\n\t\t\t\t\t\t\treturn;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif (pact) {\n\t\t\t\t\t_settle(pact, 1, result);\n\t\t\t\t} else {\n\t\t\t\t\tpact = result;\n\t\t\t\t}\n\t\t\t} catch (e) {\n\t\t\t\t_settle(pact || (pact = new _Pact()), 2, e);\n\t\t\t}\n\t\t}\n\t\t_cycle();\n\t\tif (iterator.return) {\n\t\t\tvar _fixup = function(value) {\n\t\t\t\ttry {\n\t\t\t\t\tif (!step.done) {\n\t\t\t\t\t\titerator.return();\n\t\t\t\t\t}\n\t\t\t\t} catch(e) {\n\t\t\t\t}\n\t\t\t\treturn value;\n\t\t\t}\n\t\t\tif (pact && pact.then) {\n\t\t\t\treturn pact.then(_fixup, function(e) {\n\t\t\t\t\tthrow _fixup(e);\n\t\t\t\t});\n\t\t\t}\n\t\t\t_fixup();\n\t\t}\n\t\treturn pact;\n\t}\n\t// No support for Symbol.iterator\n\tif (!(\"length\" in target)) {\n\t\tthrow new TypeError(\"Object is not iterable\");\n\t}\n\t// Handle live collections properly\n\tvar values = [];\n\tfor (var i = 0; i < target.length; i++) {\n\t\tvalues.push(target[i]);\n\t}\n\treturn _forTo(values, function(i) { return body(values[i]); }, check);\n}\n\nexport const _asyncIteratorSymbol = /*#__PURE__*/ typeof Symbol !== \"undefined\" ? (Symbol.asyncIterator || (Symbol.asyncIterator = Symbol(\"Symbol.asyncIterator\"))) : \"@@asyncIterator\";\n\n// Asynchronously iterate on a value using it's async iterator if present, or its synchronous iterator if missing\nexport function _forAwaitOf(target, body, check) {\n\tif (typeof target[_asyncIteratorSymbol] === \"function\") {\n\t\tvar pact = new _Pact();\n\t\tvar iterator = target[_asyncIteratorSymbol]();\n\t\titerator.next().then(_resumeAfterNext).then(void 0, _reject);\n\t\treturn pact;\n\t\tfunction _resumeAfterBody(result) {\n\t\t\tif (check && check()) {\n\t\t\t\treturn _settle(pact, 1, iterator.return ? iterator.return().then(function() { return result; }) : result);\n\t\t\t}\n\t\t\titerator.next().then(_resumeAfterNext).then(void 0, _reject);\n\t\t}\n\t\tfunction _resumeAfterNext(step) {\n\t\t\tif (step.done) {\n\t\t\t\t_settle(pact, 1);\n\t\t\t} else {\n\t\t\t\tPromise.resolve(body(step.value)).then(_resumeAfterBody).then(void 0, _reject);\n\t\t\t}\n\t\t}\n\t\tfunction _reject(error) {\n\t\t\t_settle(pact, 2, iterator.return ? iterator.return().then(function() { return error; }) : error);\n\t\t}\n\t}\n\treturn Promise.resolve(_forOf(target, function(value) { return Promise.resolve(value).then(body); }, check));\n}\n\n// Asynchronously implement a generic for loop\nexport function _for(test, update, body) {\n\tvar stage;\n\tfor (;;) {\n\t\tvar shouldContinue = test();\n\t\tif (_isSettledPact(shouldContinue)) {\n\t\t\tshouldContinue = shouldContinue.v;\n\t\t}\n\t\tif (!shouldContinue) {\n\t\t\treturn result;\n\t\t}\n\t\tif (shouldContinue.then) {\n\t\t\tstage = 0;\n\t\t\tbreak;\n\t\t}\n\t\tvar result = body();\n\t\tif (result && result.then) {\n\t\t\tif (_isSettledPact(result)) {\n\t\t\t\tresult = result.s;\n\t\t\t} else {\n\t\t\t\tstage = 1;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tif (update) {\n\t\t\tvar updateValue = update();\n\t\t\tif (updateValue && updateValue.then && !_isSettledPact(updateValue)) {\n\t\t\t\tstage = 2;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n\tvar pact = new _Pact();\n\tvar reject = _settle.bind(null, pact, 2);\n\t(stage === 0 ? shouldContinue.then(_resumeAfterTest) : stage === 1 ? result.then(_resumeAfterBody) : updateValue.then(_resumeAfterUpdate)).then(void 0, reject);\n\treturn pact;\n\tfunction _resumeAfterBody(value) {\n\t\tresult = value;\n\t\tdo {\n\t\t\tif (update) {\n\t\t\t\tupdateValue = update();\n\t\t\t\tif (updateValue && updateValue.then && !_isSettledPact(updateValue)) {\n\t\t\t\t\tupdateValue.then(_resumeAfterUpdate).then(void 0, reject);\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t}\n\t\t\tshouldContinue = test();\n\t\t\tif (!shouldContinue || (_isSettledPact(shouldContinue) && !shouldContinue.v)) {\n\t\t\t\t_settle(pact, 1, result);\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tif (shouldContinue.then) {\n\t\t\t\tshouldContinue.then(_resumeAfterTest).then(void 0, reject);\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tresult = body();\n\t\t\tif (_isSettledPact(result)) {\n\t\t\t\tresult = result.v;\n\t\t\t}\n\t\t} while (!result || !result.then);\n\t\tresult.then(_resumeAfterBody).then(void 0, reject);\n\t}\n\tfunction _resumeAfterTest(shouldContinue) {\n\t\tif (shouldContinue) {\n\t\t\tresult = body();\n\t\t\tif (result && result.then) {\n\t\t\t\tresult.then(_resumeAfterBody).then(void 0, reject);\n\t\t\t} else {\n\t\t\t\t_resumeAfterBody(result);\n\t\t\t}\n\t\t} else {\n\t\t\t_settle(pact, 1, result);\n\t\t}\n\t}\n\tfunction _resumeAfterUpdate() {\n\t\tif (shouldContinue = test()) {\n\t\t\tif (shouldContinue.then) {\n\t\t\t\tshouldContinue.then(_resumeAfterTest).then(void 0, reject);\n\t\t\t} else {\n\t\t\t\t_resumeAfterTest(shouldContinue);\n\t\t\t}\n\t\t} else {\n\t\t\t_settle(pact, 1, result);\n\t\t}\n\t}\n}\n\n// Asynchronously implement a do ... while loop\nexport function _do(body, test) {\n\tvar awaitBody;\n\tdo {\n\t\tvar result = body();\n\t\tif (result && result.then) {\n\t\t\tif (_isSettledPact(result)) {\n\t\t\t\tresult = result.v;\n\t\t\t} else {\n\t\t\t\tawaitBody = true;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tvar shouldContinue = test();\n\t\tif (_isSettledPact(shouldContinue)) {\n\t\t\tshouldContinue = shouldContinue.v;\n\t\t}\n\t\tif (!shouldContinue) {\n\t\t\treturn result;\n\t\t}\n\t} while (!shouldContinue.then);\n\tconst pact = new _Pact();\n\tconst reject = _settle.bind(null, pact, 2);\n\t(awaitBody ? result.then(_resumeAfterBody) : shouldContinue.then(_resumeAfterTest)).then(void 0, reject);\n\treturn pact;\n\tfunction _resumeAfterBody(value) {\n\t\tresult = value;\n\t\tfor (;;) {\n\t\t\tshouldContinue = test();\n\t\t\tif (_isSettledPact(shouldContinue)) {\n\t\t\t\tshouldContinue = shouldContinue.v;\n\t\t\t}\n\t\t\tif (!shouldContinue) {\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tif (shouldContinue.then) {\n\t\t\t\tshouldContinue.then(_resumeAfterTest).then(void 0, reject);\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tresult = body();\n\t\t\tif (result && result.then) {\n\t\t\t\tif (_isSettledPact(result)) {\n\t\t\t\t\tresult = result.v;\n\t\t\t\t} else {\n\t\t\t\t\tresult.then(_resumeAfterBody).then(void 0, reject);\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t_settle(pact, 1, result);\n\t}\n\tfunction _resumeAfterTest(shouldContinue) {\n\t\tif (shouldContinue) {\n\t\t\tdo {\n\t\t\t\tresult = body();\n\t\t\t\tif (result && result.then) {\n\t\t\t\t\tif (_isSettledPact(result)) {\n\t\t\t\t\t\tresult = result.v;\n\t\t\t\t\t} else {\n\t\t\t\t\t\tresult.then(_resumeAfterBody).then(void 0, reject);\n\t\t\t\t\t\treturn;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tshouldContinue = test();\n\t\t\t\tif (_isSettledPact(shouldContinue)) {\n\t\t\t\t\tshouldContinue = shouldContinue.v;\n\t\t\t\t}\n\t\t\t\tif (!shouldContinue) {\n\t\t\t\t\t_settle(pact, 1, result);\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t} while (!shouldContinue.then);\n\t\t\tshouldContinue.then(_resumeAfterTest).then(void 0, reject);\n\t\t} else {\n\t\t\t_settle(pact, 1, result);\n\t\t}\n\t}\n}\n\n// Asynchronously implement a switch statement\nexport function _switch(discriminant, cases) {\n\tvar dispatchIndex = -1;\n\tvar awaitBody;\n\touter: {\n\t\tfor (var i = 0; i < cases.length; i++) {\n\t\t\tvar test = cases[i][0];\n\t\t\tif (test) {\n\t\t\t\tvar testValue = test();\n\t\t\t\tif (testValue && testValue.then) {\n\t\t\t\t\tbreak outer;\n\t\t\t\t}\n\t\t\t\tif (testValue === discriminant) {\n\t\t\t\t\tdispatchIndex = i;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\t// Found the default case, set it as the pending dispatch case\n\t\t\t\tdispatchIndex = i;\n\t\t\t}\n\t\t}\n\t\tif (dispatchIndex !== -1) {\n\t\t\tdo {\n\t\t\t\tvar body = cases[dispatchIndex][1];\n\t\t\t\twhile (!body) {\n\t\t\t\t\tdispatchIndex++;\n\t\t\t\t\tbody = cases[dispatchIndex][1];\n\t\t\t\t}\n\t\t\t\tvar result = body();\n\t\t\t\tif (result && result.then) {\n\t\t\t\t\tawaitBody = true;\n\t\t\t\t\tbreak outer;\n\t\t\t\t}\n\t\t\t\tvar fallthroughCheck = cases[dispatchIndex][2];\n\t\t\t\tdispatchIndex++;\n\t\t\t} while (fallthroughCheck && !fallthroughCheck());\n\t\t\treturn result;\n\t\t}\n\t}\n\tconst pact = new _Pact();\n\tconst reject = _settle.bind(null, pact, 2);\n\t(awaitBody ? result.then(_resumeAfterBody) : testValue.then(_resumeAfterTest)).then(void 0, reject);\n\treturn pact;\n\tfunction _resumeAfterTest(value) {\n\t\tfor (;;) {\n\t\t\tif (value === discriminant) {\n\t\t\t\tdispatchIndex = i;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tif (++i === cases.length) {\n\t\t\t\tif (dispatchIndex !== -1) {\n\t\t\t\t\tbreak;\n\t\t\t\t} else {\n\t\t\t\t\t_settle(pact, 1, result);\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t}\n\t\t\ttest = cases[i][0];\n\t\t\tif (test) {\n\t\t\t\tvalue = test();\n\t\t\t\tif (value && value.then) {\n\t\t\t\t\tvalue.then(_resumeAfterTest).then(void 0, reject);\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tdispatchIndex = i;\n\t\t\t}\n\t\t}\n\t\tdo {\n\t\t\tvar body = cases[dispatchIndex][1];\n\t\t\twhile (!body) {\n\t\t\t\tdispatchIndex++;\n\t\t\t\tbody = cases[dispatchIndex][1];\n\t\t\t}\n\t\t\tvar result = body();\n\t\t\tif (result && result.then) {\n\t\t\t\tresult.then(_resumeAfterBody).then(void 0, reject);\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tvar fallthroughCheck = cases[dispatchIndex][2];\n\t\t\tdispatchIndex++;\n\t\t} while (fallthroughCheck && !fallthroughCheck());\n\t\t_settle(pact, 1, result);\n\t}\n\tfunction _resumeAfterBody(result) {\n\t\tfor (;;) {\n\t\t\tvar fallthroughCheck = cases[dispatchIndex][2];\n\t\t\tif (!fallthroughCheck || fallthroughCheck()) {\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tdispatchIndex++;\n\t\t\tvar body = cases[dispatchIndex][1];\n\t\t\twhile (!body) {\n\t\t\t\tdispatchIndex++;\n\t\t\t\tbody = cases[dispatchIndex][1];\n\t\t\t}\n\t\t\tresult = body();\n\t\t\tif (result && result.then) {\n\t\t\t\tresult.then(_resumeAfterBody).then(void 0, reject);\n\t\t\t\treturn;\n\t\t\t}\n\t\t}\n\t\t_settle(pact, 1, result);\n\t}\n}\n\n// Asynchronously call a function and pass the result to explicitly passed continuations\nexport function _call(body, then, direct) {\n\tif (direct) {\n\t\treturn then ? then(body()) : body();\n\t}\n\ttry {\n\t\tvar result = Promise.resolve(body());\n\t\treturn then ? result.then(then) : result;\n\t} catch (e) {\n\t\treturn Promise.reject(e);\n\t}\n}\n\n// Asynchronously call a function and swallow the result\nexport function _callIgnored(body, direct) {\n\treturn _call(body, _empty, direct);\n}\n\n// Asynchronously call a function and pass the result to explicitly passed continuations\nexport function _invoke(body, then) {\n\tvar result = body();\n\tif (result && result.then) {\n\t\treturn result.then(then);\n\t}\n\treturn then(result);\n}\n\n// Asynchronously call a function and swallow the result\nexport function _invokeIgnored(body) {\n\tvar result = body();\n\tif (result && result.then) {\n\t\treturn result.then(_empty);\n\t}\n}\n\n// Asynchronously call a function and send errors to recovery continuation\nexport function _catch(body, recover) {\n\ttry {\n\t\tvar result = body();\n\t} catch(e) {\n\t\treturn recover(e);\n\t}\n\tif (result && result.then) {\n\t\treturn result.then(void 0, recover);\n\t}\n\treturn result;\n}\n\n// Asynchronously await a promise and pass the result to a finally continuation\nexport function _finallyRethrows(body, finalizer) {\n\ttry {\n\t\tvar result = body();\n\t} catch (e) {\n\t\treturn finalizer(true, e);\n\t}\n\tif (result && result.then) {\n\t\treturn result.then(finalizer.bind(null, false), finalizer.bind(null, true));\n\t}\n\treturn finalizer(false, result);\n}\n\n// Asynchronously await a promise and invoke a finally continuation that always overrides the result\nexport function _finally(body, finalizer) {\n\ttry {\n\t\tvar result = body();\n\t} catch (e) {\n\t\treturn finalizer();\n\t}\n\tif (result && result.then) {\n\t\treturn result.then(finalizer, finalizer);\n\t}\n\treturn finalizer();\n}\n\n// Rethrow or return a value from a finally continuation\nexport function _rethrow(thrown, value) {\n\tif (thrown)\n\t\tthrow value;\n\treturn value;\n}\n\n// Empty function to implement break and other control flow that ignores asynchronous results\nexport function _empty() {\n}\n\n// Sentinel value for early returns in generators \nexport const _earlyReturn = /*#__PURE__*/ {};\n\n// Asynchronously call a function and send errors to recovery continuation, skipping early returns\nexport function _catchInGenerator(body, recover) {\n\treturn _catch(body, function(e) {\n\t\tif (e === _earlyReturn) {\n\t\t\tthrow e;\n\t\t}\n\t\treturn recover(e);\n\t});\n}\n\n// Asynchronous generator class; accepts the entrypoint of the generator, to which it passes itself when the generator should start\nexport const _AsyncGenerator = /*#__PURE__*/(function() {\n\tfunction _AsyncGenerator(entry) {\n\t\tthis._entry = entry;\n\t\tthis._pact = null;\n\t\tthis._resolve = null;\n\t\tthis._return = null;\n\t\tthis._promise = null;\n\t}\n\n\tfunction _wrapReturnedValue(value) {\n\t\treturn { value: value, done: true };\n\t}\n\tfunction _wrapYieldedValue(value) {\n\t\treturn { value: value, done: false };\n\t}\n\n\t_AsyncGenerator.prototype._yield = function(value) {\n\t\t// Yield the value to the pending next call\n\t\tthis._resolve(value && value.then ? value.then(_wrapYieldedValue) : _wrapYieldedValue(value));\n\t\t// Return a pact for an upcoming next/return/throw call\n\t\treturn this._pact = new _Pact();\n\t};\n\t_AsyncGenerator.prototype.next = function(value) {\n\t\t// Advance the generator, starting it if it has yet to be started\n\t\tconst _this = this;\n\t\treturn _this._promise = new Promise(function (resolve) {\n\t\t\tconst _pact = _this._pact;\n\t\t\tif (_pact === null) {\n\t\t\t\tconst _entry = _this._entry;\n\t\t\t\tif (_entry === null) {\n\t\t\t\t\t// Generator is started, but not awaiting a yield expression\n\t\t\t\t\t// Abandon the next call!\n\t\t\t\t\treturn resolve(_this._promise);\n\t\t\t\t}\n\t\t\t\t// Start the generator\n\t\t\t\t_this._entry = null;\n\t\t\t\t_this._resolve = resolve;\n\t\t\t\tfunction returnValue(value) {\n\t\t\t\t\t_this._resolve(value && value.then ? value.then(_wrapReturnedValue) : _wrapReturnedValue(value));\n\t\t\t\t\t_this._pact = null;\n\t\t\t\t\t_this._resolve = null;\n\t\t\t\t}\n\t\t\t\tvar result = _entry(_this);\n\t\t\t\tif (result && result.then) {\n\t\t\t\t\tresult.then(returnValue, function(error) {\n\t\t\t\t\t\tif (error === _earlyReturn) {\n\t\t\t\t\t\t\treturnValue(_this._return);\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tconst pact = new _Pact();\n\t\t\t\t\t\t\t_this._resolve(pact);\n\t\t\t\t\t\t\t_this._pact = null;\n\t\t\t\t\t\t\t_this._resolve = null;\n\t\t\t\t\t\t\t_resolve(pact, 2, error);\n\t\t\t\t\t\t}\n\t\t\t\t\t});\n\t\t\t\t} else {\n\t\t\t\t\treturnValue(result);\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\t// Generator is started and a yield expression is pending, settle it\n\t\t\t\t_this._pact = null;\n\t\t\t\t_this._resolve = resolve;\n\t\t\t\t_settle(_pact, 1, value);\n\t\t\t}\n\t\t});\n\t};\n\t_AsyncGenerator.prototype.return = function(value) {\n\t\t// Early return from the generator if started, otherwise abandons the generator\n\t\tconst _this = this;\n\t\treturn _this._promise = new Promise(function (resolve) {\n\t\t\tconst _pact = _this._pact;\n\t\t\tif (_pact === null) {\n\t\t\t\tif (_this._entry === null) {\n\t\t\t\t\t// Generator is started, but not awaiting a yield expression\n\t\t\t\t\t// Abandon the return call!\n\t\t\t\t\treturn resolve(_this._promise);\n\t\t\t\t}\n\t\t\t\t// Generator is not started, abandon it and return the specified value\n\t\t\t\t_this._entry = null;\n\t\t\t\treturn resolve(value && value.then ? value.then(_wrapReturnedValue) : _wrapReturnedValue(value));\n\t\t\t}\n\t\t\t// Settle the yield expression with a rejected \"early return\" value\n\t\t\t_this._return = value;\n\t\t\t_this._resolve = resolve;\n\t\t\t_this._pact = null;\n\t\t\t_settle(_pact, 2, _earlyReturn);\n\t\t});\n\t};\n\t_AsyncGenerator.prototype.throw = function(error) {\n\t\t// Inject an exception into the pending yield expression\n\t\tconst _this = this;\n\t\treturn _this._promise = new Promise(function (resolve, reject) {\n\t\t\tconst _pact = _this._pact;\n\t\t\tif (_pact === null) {\n\t\t\t\tif (_this._entry === null) {\n\t\t\t\t\t// Generator is started, but not awaiting a yield expression\n\t\t\t\t\t// Abandon the throw call!\n\t\t\t\t\treturn resolve(_this._promise);\n\t\t\t\t}\n\t\t\t\t// Generator is not started, abandon it and return a rejected Promise containing the error\n\t\t\t\t_this._entry = null;\n\t\t\t\treturn reject(error);\n\t\t\t}\n\t\t\t// Settle the yield expression with the value as a rejection\n\t\t\t_this._resolve = resolve;\n\t\t\t_this._pact = null;\n\t\t\t_settle(_pact, 2, error);\n\t\t});\n\t};\n\n\t_AsyncGenerator.prototype[_asyncIteratorSymbol] = function() {\n\t\treturn this;\n\t};\n\t\n\treturn _AsyncGenerator;\n})();\n","import { Validator } from \"./form\";\n\n// yup type stubs\ninterface YupValidationError {\n    path?: string;\n    message?: string;\n    inner: YupValidationError[];\n}\ninterface YupValidationOptions {\n    strict?: boolean;\n    abortEarly?: boolean;\n    stripUnknown?: boolean;\n    recursive?: boolean;\n    context?: any;\n}\n\nexport function yupValidator<T, Error>(\n    yupSchema: any,\n    options?: YupValidationOptions,\n    messageTransformer: (message: string) => Error = (e) => e as any\n): Validator<T, Error> {\n    return async (values: T) => {\n        try {\n            await yupSchema.validate(values, options);\n            return {};\n        } catch (ex) {\n            return yupErrorToErrorMap(ex, messageTransformer);\n        }\n    };\n}\n\nexport function yupErrorToErrorMap<Error>(error: YupValidationError, errorTransformer: (message: string) => Error) {\n    let errors = error.path ? [error] : error.inner;\n    let obj = {};\n    for (let i = 0; i < errors.length; i++) {\n        let err = errors[i];\n        if (!err.path || !err.message) continue;\n        let pathSegments = Array.from(err.path.matchAll(/(\\w+)/gi)).map((e) => e[0]);\n        let o = obj;\n        for (let j = 0; j < pathSegments.length; j++) {\n            let key = pathSegments[j];\n            let oo = o[key];\n            if (!oo) {\n                oo = {};\n                o[key] = oo;\n            }\n            if (j === pathSegments.length - 1) {\n                o[key] = errorTransformer(err.message);\n            } else {\n                o = oo;\n            }\n        }\n    }\n    return obj;\n}\n","import React, { useEffect, useRef, useState } from \"react\";\nimport { ChildFormState, DirtyMap, ErrorMap, FormState } from \"./form\";\nimport { useArrayForm, useListener, useAnyListener, useChildForm } from \"./hooks\";\n\n/**\n * Wrapper around useArrayForm (which is a wrapper around useChildForm).\n * Exports useful functions to manipulate arrays.\n * This hook does cause a rerender, but only if the whole array changes.\n * @param parent The parent form.\n * @param name The parent's field to create a child form for.\n */\nexport function ArrayForm<Parent, ParentState, ParentError, Key extends keyof Parent>(props: {\n    form: FormState<Parent, ParentState, ParentError>;\n    name: Key;\n    render?: (props: {\n        form: ChildFormState<Parent, ParentState, ParentError, Key>;\n        remove: (index: number) => void;\n        clear: () => void;\n        move: (index: number, newIndex: number) => void;\n        swap: (index: number, newIndex: number) => void;\n        append: (value: NonNullable<Parent[Key]>[keyof NonNullable<Parent[Key]>]) => void;\n        values: NonNullable<Parent[Key]>;\n        setValues: (values: NonNullable<Parent[Key]>) => void;\n    }) => React.ReactNode;\n}) {\n    const childForm = useArrayForm(props.form, props.name);\n    const oldThruthly = useRef(!!props.form.values[props.name]);\n    const [, setRender] = useState(0);\n\n    // Rerender when array became null/not null (thruthly/falsely)\n    useEffect(() => {\n        let id = props.form.listen(props.name, () => {\n            let thruthly = !!props.form.values[props.name];\n            if (thruthly !== oldThruthly.current) {\n                setRender((i) => i + 1);\n                oldThruthly.current = thruthly;\n            }\n        });\n        return () => props.form.ignore(props.name, id);\n    }, []);\n\n    // Do not render anything if the parent field is falsly\n    if (!props.form.values[props.name]) return null;\n    return <React.Fragment>{props.render?.(childForm) ?? childForm.values + \"\"}</React.Fragment>;\n}\n\n/**\n * Wrapper around useListener\n * Listen for changes on a form's field. Behaves like useState.\n * You shouldn't use this hook in large components, as it rerenders each time something changes. Use the wrapper <Listener /> instead.\n * @param form The form to listen on.\n * @param name The form's field to listen to.\n */\nexport function Listener<T, State, Error, Key extends keyof T>(props: {\n    form: FormState<T, State, Error>;\n    name: Key;\n    render?: (props: {\n        value: T[Key];\n        defaultValue: T[Key];\n        setValue: (value: T[Key]) => void;\n        dirty: DirtyMap<T>[Key];\n        error: ErrorMap<T, Error>[Key];\n        state: State;\n        form: FormState<T, State, Error>;\n    }) => React.ReactNode;\n}) {\n    const l = useListener(props.form, props.name);\n    return <React.Fragment>{props.render?.(l) ?? l.value + \"\"}</React.Fragment>;\n}\n\n/**\n * Wrapper around useAnyListener.\n * Listens for any change on this form. Behaves like useState.\n * You shouldn't use this hook in large components, as it rerenders each time something changes. Use the wrapper <AnyListener /> instead.\n * @param form The form to listen to.\n */\nexport function AnyListener<T, State, Error>(props: {\n    form: FormState<T, State, Error>;\n    render?: (props: FormState<T, State, Error>) => React.ReactNode;\n}) {\n    const l = useAnyListener(props.form);\n    return <React.Fragment>{props.render?.(l) ?? l.values + \"\"}</React.Fragment>;\n}\n\n/**\n * Wrapper around useChildForm\n * Creates a child form for another root or child form. You must use this for object and array (see useArrayForm) fields.\n * This hook doesn't cause a rerender.\n * @param parentForm The parent form.\n * @param name The parent's field to create a child form for.\n */\nexport function ChildForm<Parent, ParentState, ParentError, Key extends keyof Parent>(props: {\n    form: FormState<Parent, ParentState, ParentError>; // Use the parent prop instead of the form prop when using ChildForm.\n    name: Key;\n    render?: (props: ChildFormState<Parent, ParentState, ParentError, Key>) => React.ReactNode;\n}) {\n    const childForm = useChildForm(props.form, props.name);\n    const oldThruthly = useRef(!!props.form.values[props.name]);\n    const [, setRender] = useState(0);\n\n    // Only rerender when object became null/not null (thruthly/falsely)\n    useEffect(() => {\n        let id = props.form.listen(props.name, () => {\n            let thruthly = !!props.form.values[props.name];\n            if (thruthly !== oldThruthly.current) {\n                setRender((i) => i + 1);\n                oldThruthly.current = thruthly;\n            }\n        });\n        return () => props.form.ignore(props.name, id);\n    }, []);\n\n    // Do not render anything if the parent field is falsly\n    if (!props.form.values[props.name]) return null;\n    return <React.Fragment>{props.render?.(childForm)}</React.Fragment>;\n}\n","import React, { HTMLAttributes } from \"react\";\nimport { FormState } from \"../form\";\nimport { useListener } from \"../hooks\";\n\nexport type FormErrorProps<T, Error, Key extends keyof T> = Omit<HTMLAttributes<HTMLParagraphElement>, \"name\" | \"form\"> & {\n    form: FormState<T, any, Error>;\n    name: Key;\n};\n\nexport function FormError<T, Error, Key extends keyof T>({ form, name, ...rest }: FormErrorProps<T, Error, Key>) {\n    const { error } = useListener(form, name);\n    if (!error || typeof error === \"object\") return null;\n    return <p {...rest}>{error + \"\"}</p>;\n}\n","import React, { SelectHTMLAttributes } from \"react\";\nimport { DefaultState, FormState } from \"../form\";\nimport { DEFAULT_DIRTY_CLASS, DEFAULT_ERROR_CLASS, getClassName } from \"./FormInput\";\nimport { useListener } from \"../hooks\";\n\nexport type FormSelectProps<T, State, Error> = Omit<SelectHTMLAttributes<HTMLSelectElement>, \"form\" | \"name\"> & {\n    form: FormState<T, State, Error>;\n    name: keyof T;\n    errorClassName?: string;\n    errorStyle?: React.CSSProperties;\n    dirtyClassName?: string;\n    dirtyStyle?: React.CSSProperties;\n    disableOnSubmitting?: boolean;\n    hideWhenNull?: boolean;\n};\n\nexport function FormSelect<T, State extends DefaultState, Error>({\n    form,\n    name,\n    errorClassName,\n    errorStyle,\n    dirtyClassName,\n    dirtyStyle,\n    disableOnSubmitting,\n    hideWhenNull,\n    children,\n    className,\n    style,\n    ...rest\n}: FormSelectProps<T, State, Error>) {\n    const { value, setValue, state, dirty, error } = useListener(form, name);\n    if (hideWhenNull && (value === null || value === undefined)) return null;\n    return (\n        <select\n            style={{\n                ...style,\n                ...(dirty && dirtyStyle),\n                ...(error && errorStyle)\n            }}\n            className={getClassName(className, dirty && (dirtyClassName ?? DEFAULT_DIRTY_CLASS), error && (errorClassName ?? DEFAULT_ERROR_CLASS))}\n            disabled={(disableOnSubmitting ?? true) && state.isSubmitting}\n            value={value as any}\n            onChange={(ev) => {\n                if (rest.multiple) setValue(Array.from(ev.target.selectedOptions).map((e) => e.value) as any);\n                else setValue(ev.target.value as any);\n            }}\n            {...rest}\n        >\n            {children}\n        </select>\n    );\n}\n","import React, { TextareaHTMLAttributes } from \"react\";\nimport { DefaultState, FormState } from \"../form\";\nimport { DEFAULT_DIRTY_CLASS, DEFAULT_ERROR_CLASS, getClassName } from \"./FormInput\";\nimport { useListener } from \"../hooks\";\n\nexport type FormTextAreaProps<T, State, Error> = Omit<TextareaHTMLAttributes<HTMLTextAreaElement>, \"form\" | \"name\"> & {\n    form: FormState<T, State, Error>;\n    name: keyof T;\n    errorClassName?: string;\n    errorStyle?: React.CSSProperties;\n    dirtyClassName?: string;\n    dirtyStyle?: React.CSSProperties;\n    disableOnSubmitting?: boolean;\n    hideWhenNull?: boolean;\n};\n\nexport function FormTextArea<T, State extends DefaultState, Error>({\n    form,\n    name,\n    errorClassName,\n    errorStyle,\n    dirtyClassName,\n    dirtyStyle,\n    disableOnSubmitting,\n    children,\n    className,\n    hideWhenNull,\n    style,\n    ...rest\n}: FormTextAreaProps<T, State, Error>) {\n    const { value, setValue, state, dirty, error } = useListener(form, name);\n    if (hideWhenNull && (value === null || value === undefined)) return null;\n    return (\n        <textarea\n            style={{\n                ...style,\n                ...(dirty && dirtyStyle),\n                ...(error && errorStyle)\n            }}\n            className={getClassName(className, dirty && (dirtyClassName ?? DEFAULT_DIRTY_CLASS), error && (errorClassName ?? DEFAULT_ERROR_CLASS))}\n            disabled={(disableOnSubmitting ?? true) && state.isSubmitting}\n            value={value as any}\n            onChange={(ev) => setValue(ev.target.value as any)}\n            {...rest}\n        >\n            {children}\n        </textarea>\n    );\n}\n","import React, { useRef } from \"react\";\n\nexport function VisualRender(props: { children: React.ReactNode }) {\n    let ref = useRef<HTMLDivElement>(null);\n    let timeoutRef = useRef<number | null>(null);\n\n    if (ref.current) {\n        ref.current.className = \"\";\n        if (timeoutRef.current) clearTimeout(timeoutRef.current);\n        timeoutRef.current = window.setTimeout(() => {\n            ref.current && (ref.current.className = \"blink\");\n        }, 100);\n    }\n\n    return (\n        <div className=\"blink\" ref={ref}>\n            {props.children}\n        </div>\n    );\n}\n","import React, { useState } from \"react\";\nimport {\n    AnyListener,\n    ArrayForm,\n    FormError,\n    FormState,\n    FormInput,\n    FormSelect,\n    useAnyListener,\n    useChildForm,\n    useForm,\n    Listener,\n    FormTextArea,\n    ChildForm\n} from \"typed-react-form\";\nimport { VisualRender } from \"./VisualRender\";\n\ninterface ExampleFormData {\n    id: number;\n    name: string;\n    description: string;\n    author: User | null;\n    public: boolean;\n    date: number;\n    dateObject: Date;\n    language: \"en\" | \"nl\" | \"fr\";\n    tags: string[];\n    todos: Todo[];\n}\n\ninterface Todo {\n    message: string;\n    priority: \"low\" | \"normal\" | \"high\";\n}\n\ninterface User {\n    name: string;\n    age: number;\n}\n\n// function Test() {\n//     const [values, setValues] = useState({ name: \"Onderzoek\", age: 18, author: { name: \"Stijn\", email: \"reddusted@gmail.com\" }, test: undefined });\n//     const form = useForm(values);\n\n//     return (\n//         <form\n//             onSubmit={(ev) => {\n//                 ev.preventDefault();\n//                 console.log(\"submit\", form.values);\n//                 setValues({ ...form.values, test: { name: \"yikes\" } as any });\n//             }}\n//             onReset={() => {\n//                 form.resetAll();\n//             }}\n//         >\n//             <p>Name</p>\n//             <FormInput form={form} name=\"name\" />\n//             <p>Age</p>\n//             <FormInput form={form} type=\"number\" name=\"age\" />\n//             <p>Author</p>\n//             <FormInput form={form} type=\"checkbox\" name=\"author\" setNullOnUncheck value={{ name: \"\", email: \"\" }} />\n//             <ChildForm\n//                 form={form}\n//                 name=\"author\"\n//                 render={(form) => (\n//                     <>\n//                         <p>Name</p>\n//                         <FormInput form={form} type=\"text\" name=\"name\" />\n//                         <p>Email</p>\n//                         <FormInput form={form} type=\"text\" name=\"email\" />\n//                     </>\n//                 )}\n//             />\n//             <Listener\n//                 form={form}\n//                 name=\"author\"\n//                 onlyOnSetValue\n//                 render={(form) => (\n//                     <VisualRender>\n//                         <code>render? {JSON.stringify(form.value, null, 2)}</code>\n//                     </VisualRender>\n//                 )}\n//             />\n//             <AnyListener\n//                 form={form}\n//                 render={(form) => (\n//                     <VisualRender>\n//                         <pre>{JSON.stringify(form.values)}</pre>\n//                         <pre>{JSON.stringify(form.defaultValues)}</pre>\n//                         <pre>{JSON.stringify(form.dirtyMap)}</pre>\n//                         <button disabled={!form.dirty || form.error}>Submit</button>\n//                         <button disabled={!form.dirty || form.error} type=\"reset\">\n//                             Reset\n//                         </button>\n//                     </VisualRender>\n//                 )}\n//             />\n//         </form>\n//     );\n// }\n\n// export default Test;\n\nexport default function App() {\n    return (\n        <div>\n            <div style={{ padding: \"2em\", background: \"#333\", color: \"white\" }}>\n                <h1>\n                    Example form created using{\" \"}\n                    <a style={{ color: \"#3793ee\" }} href=\"https://github.com/CodeStix/typed-react-form\">\n                        typed-react-form\n                    </a>\n                </h1>\n                <p>\n                    The <strong style={{ color: \"red\" }}>red flash</strong> indicates which parts of the form are being rerendered. The{\" \"}\n                    <strong style={{ outline: \"3px solid gray\" }}>gray outline</strong> indicates that a field is dirty (modified) and the{\" \"}\n                    <strong style={{ outline: \"3px solid red\" }}>red outline</strong> indicates an error.\n                </p>\n                <p>\n                    Every part of this form's{\" \"}\n                    <a style={{ color: \"#3793ee\" }} href=\"https://github.com/CodeStix/typed-react-form/blob/master/example/src/App.tsx\">\n                        source code\n                    </a>{\" \"}\n                    is type-checked.\n                </p>\n            </div>\n            <Form />\n        </div>\n    );\n}\n\nconst initialValues: ExampleFormData = {\n    id: Math.ceil(Math.random() * 100000),\n    name: \"My todo list\",\n    description: \"this is a testing form\",\n    author: null,\n    public: true,\n    date: new Date().getTime(),\n    dateObject: new Date(),\n    tags: [\"test\"],\n    language: \"en\",\n    todos: [{ message: \"This is todo\", priority: \"normal\" }]\n};\n\nexport function Form() {\n    const form = useForm(\n        initialValues, // <- Default values, may change\n        { isSubmitting: false }, // <- Global form state, which can contain custom fields (e.g. loading)\n        validateTodoList, // <- Validator\n        false, // <- Validate on mount\n        true // <- Validate on change\n    );\n\n    return (\n        <form\n            onSubmit={async (ev) => {\n                ev.preventDefault();\n\n                form.validate(); // Validate manually when validateOnChange is disabled.\n                if (form.error) return; // Do not submit if errors\n\n                form.setState({ isSubmitting: true }); // Set the form state (updates every component listening for state updates)\n\n                await new Promise((res) => setTimeout(res, 1000)); // Fake fetch\n\n                form.setState({ isSubmitting: false }); // Set the form state (updates every component listening for state updates)\n                form.setDefaultValues(form.values); // Set new default values\n            }}\n        >\n            <div style={{ display: \"grid\", gridTemplateColumns: \"60% 40%\", gridTemplateRows: \"100%\", gap: \"2em\", margin: \"2em\" }}>\n                <VisualRender>\n                    <h3>\n                        Id <small>number</small>\n                    </h3>\n                    <FormInput type=\"number\" form={form} name=\"id\" />\n                    <hr />\n                    <h3>\n                        Name <small>string</small>\n                    </h3>\n                    <FormInput form={form} name=\"name\" />\n                    <FormError form={form} name=\"name\" />\n                    <hr />\n                    <h3>\n                        Public? <small>boolean</small>\n                    </h3>\n                    <p>Using radio buttons</p>\n                    <FormInput type=\"radio\" form={form} name=\"public\" value={false} /> no\n                    <FormInput type=\"radio\" form={form} name=\"public\" value={true} /> yes\n                    <p>Using checkbox</p>\n                    <FormInput type=\"checkbox\" form={form} name=\"public\" />\n                    <hr />\n                    <h3>\n                        Language <small>enum</small>\n                    </h3>\n                    <p>Using select</p>\n                    <FormSelect form={form} name=\"language\">\n                        <option value=\"en\">English</option>\n                        <option value=\"nl\">Dutch</option>\n                        <option value=\"fr\">French</option>\n                    </FormSelect>\n                    <p>Using radio buttons</p>\n                    <FormInput type=\"radio\" form={form} name=\"language\" value=\"en\" /> English\n                    <FormInput type=\"radio\" form={form} name=\"language\" value=\"nl\" /> Dutch\n                    <FormInput type=\"radio\" form={form} name=\"language\" value=\"fr\" /> French\n                    <hr />\n                    <h3>\n                        Todo's <small>dynamic array</small>\n                    </h3>\n                    {/* Use ArrayForm (wrapper around useArrayForm) to create dynamic forms */}\n                    <FormError form={form} name=\"todos\" />\n                    <ArrayForm\n                        form={form}\n                        name=\"todos\"\n                        render={(\n                            { form, swap, remove, append, values, setValues } // <- Make sure to use the newly passed form (otherwise type checking will not work!)\n                        ) => (\n                            <VisualRender>\n                                <ul>\n                                    {form.values.map((\n                                        _,\n                                        i // You should use other key than index\n                                    ) => (\n                                        <TodoItem onMoveTop={() => swap(i, 0)} onRemove={() => remove(i)} key={i} parent={form} index={i} />\n                                    ))}\n                                </ul>\n                                <button\n                                    type=\"button\"\n                                    onClick={() => {\n                                        append({\n                                            message: \"\",\n                                            priority: \"normal\"\n                                        });\n                                    }}\n                                >\n                                    Add item\n                                </button>\n                                <button\n                                    type=\"button\"\n                                    onClick={() => {\n                                        setValues([\n                                            ...values,\n                                            ...Array(50)\n                                                .fill(0)\n                                                .map((_, i) => ({\n                                                    message: \"Fix this \" + i,\n                                                    priority: \"normal\" as \"normal\" // Wut\n                                                }))\n                                        ]);\n                                    }}\n                                >\n                                    Add 50 items\n                                </button>\n                            </VisualRender>\n                        )}\n                    />\n                    <button type=\"button\" onClick={() => form.setError(\"todos\", \"There is something wrong with the array\")}>\n                        Set array error\n                    </button>\n                    <hr />\n                    <h3>\n                        Date <small>timestamp number</small>\n                    </h3>\n                    <FormInput type=\"date\" form={form} name=\"date\" dateAsNumber />\n                    <hr />\n                    <h3>\n                        Date <small>date object</small>\n                    </h3>\n                    <FormInput type=\"date\" form={form} name=\"dateObject\" />\n                    <hr />\n                    <h3>\n                        Tags <small>string array</small>\n                    </h3>\n                    <p>\n                        Using select with <code>multiple=true</code>\n                    </p>\n                    <FormSelect form={form} name=\"tags\" multiple>\n                        <option value=\"test\">Test</option>\n                        <option value=\"fun\">Fun</option>\n                        <option value=\"school\">School</option>\n                    </FormSelect>\n                    <p>Using checkboxes</p>\n                    <label>\n                        <FormInput form={form} name=\"tags\" type=\"checkbox\" value=\"test\" />\n                        Test\n                    </label>\n                    <label>\n                        <FormInput form={form} name=\"tags\" type=\"checkbox\" value=\"fun\" />\n                        Fun\n                    </label>\n                    <label>\n                        <FormInput form={form} name=\"tags\" type=\"checkbox\" value=\"school\" />\n                        School\n                    </label>\n                    <hr />\n                    <h3>\n                        Description <small>string</small>\n                    </h3>\n                    <p>\n                        Using <code>FormTextArea</code>\n                    </p>\n                    <FormTextArea form={form} name=\"description\" rows={5} cols={50} />\n                    <p>\n                        Using <code>Listener</code> around <code>textarea</code>\n                    </p>\n                    <Listener\n                        form={form}\n                        name=\"description\"\n                        render={({ value, setValue }) => (\n                            <textarea rows={5} cols={50} value={value} onChange={(ev) => setValue(ev.target.value)}></textarea>\n                        )}\n                    />\n                    <hr />\n                    <h3>\n                        Author <small>string</small>\n                    </h3>\n                    <p>Togglable object field</p>\n                    <FormInput form={form} name=\"author\" type=\"checkbox\" setNullOnUncheck value={{ name: \"\", age: 0 }} />\n                    <ChildForm\n                        form={form}\n                        name=\"author\"\n                        render={(form) => (\n                            <VisualRender>\n                                <FormInput form={form} name=\"name\" />\n                                <FormInput form={form} name=\"age\" type=\"number\" />\n                            </VisualRender>\n                        )}\n                    />\n                </VisualRender>\n                <div style={{ position: \"sticky\", top: \"0\", height: \"500px\" }}>\n                    <h2>Output</h2>\n                    <FormValues form={form} />\n\n                    {/* Disable buttons when form is submitting or when nothing has changed, the AnyListener wrapper is required */}\n                    <AnyListener\n                        form={form}\n                        render={({ state, dirty }) => (\n                            <div style={{ margin: \"0.5em 0\" }}>\n                                <button style={{ fontSize: \"1.3em\" }} disabled={state.isSubmitting || !dirty}>\n                                    Submit\n                                </button>\n                                <button\n                                    style={{ fontSize: \"1.3em\" }}\n                                    disabled={state.isSubmitting || !dirty}\n                                    type=\"button\"\n                                    onClick={() => form.resetAll()}\n                                >\n                                    Reset\n                                </button>\n                            </div>\n                        )}\n                    />\n\n                    <div>\n                        <button style={{ fontSize: \"1.3em\" }} type=\"button\" onClick={() => form.validate()}>\n                            Validate\n                        </button>\n                        <label>\n                            <code>validateOnChange</code>\n                            <input\n                                type=\"checkbox\"\n                                defaultChecked={form.validateOnChange}\n                                onChange={(e) => (form.validateOnChange = e.target.checked)}\n                            />\n                        </label>\n                    </div>\n                </div>\n            </div>\n        </form>\n    );\n}\n\nfunction TodoItem(props: { parent: FormState<Todo[]>; index: number; onMoveTop: () => void; onRemove: () => void }) {\n    // Use a child form, each layer in the object is a seperate form: TodoList (useForm) -> Todo[] (useArrayForm) -> Todo (useChildForm)\n    const form = useChildForm(props.parent, props.index);\n\n    return (\n        <li\n            style={{\n                padding: \"0.5em\"\n            }}\n        >\n            <VisualRender>\n                <FormInput form={form} name=\"message\" />\n                <FormSelect form={form} name=\"priority\">\n                    <option value=\"low\">Low</option>\n                    <option value=\"normal\">Normal</option>\n                    <option value=\"high\">High</option>\n                </FormSelect>\n                <button type=\"button\" onClick={props.onMoveTop}>\n                    Go to top\n                </button>\n                <button type=\"button\" onClick={props.onRemove}>\n                    Remove\n                </button>\n            </VisualRender>\n        </li>\n    );\n}\n\n/**\n *  Shows a JSON representation of a form\n */\nfunction FormValues<T>(props: { form: FormState<T> }) {\n    const form = useAnyListener(props.form);\n    const [show, setShow] = useState({ values: true, defaultValues: false, errorMap: true, dirtyMap: true, state: false });\n    return (\n        <VisualRender>\n            <div style={{ background: \"#0001\", overflow: \"hidden\", padding: \"1em\", borderRadius: \"1em\" }}>\n                <p>\n                    <strong style={{ color: form.dirty ? \"blue\" : undefined }}>{form.dirty ? \"Modified\" : \"Unmodified\"}</strong>\n                </p>\n                <p>\n                    <strong style={{ color: form.error ? \"red\" : undefined }}>{form.error ? \"Has error\" : \"No errors\"}</strong>\n                </p>\n\n                <div>\n                    <strong>Show: </strong>\n                    <label>\n                        <input type=\"checkbox\" checked={show.values} onChange={(ev) => setShow({ ...show, values: ev.target.checked })} />\n                        <code>values</code>\n                    </label>\n                    <label>\n                        <input\n                            type=\"checkbox\"\n                            checked={show.defaultValues}\n                            onChange={(ev) => setShow({ ...show, defaultValues: ev.target.checked })}\n                        />\n                        <code>defaultValues</code>\n                    </label>\n                    <label>\n                        <input type=\"checkbox\" checked={show.errorMap} onChange={(ev) => setShow({ ...show, errorMap: ev.target.checked })} />\n                        <code>errorMap</code>\n                    </label>\n                    <label>\n                        <input type=\"checkbox\" checked={show.dirtyMap} onChange={(ev) => setShow({ ...show, dirtyMap: ev.target.checked })} />\n                        <code>dirtyMap</code>\n                    </label>\n                    <label>\n                        <input type=\"checkbox\" checked={show.state} onChange={(ev) => setShow({ ...show, state: ev.target.checked })} />\n                        <code>state</code>\n                    </label>\n                </div>\n\n                {show.values && <pre>values = {JSON.stringify(form.values, null, 2)}</pre>}\n                {show.defaultValues && <pre>defaultValues = {JSON.stringify(form.defaultValues, null, 2)}</pre>}\n                {show.errorMap && <pre>errorMap = {JSON.stringify(form.errorMap, null, 2)}</pre>}\n                {show.dirtyMap && <pre>dirtyMap = {JSON.stringify(form.dirtyMap, null, 2)}</pre>}\n                {show.state && <pre>state = {JSON.stringify(form.state, null, 2)}</pre>}\n            </div>\n        </VisualRender>\n    );\n}\n\n// You should use a validation library (yup, class-validator) instead of this mess...\nfunction validateTodoList(values: ExampleFormData) {\n    let todoErrors = values.todos.reduce((prev, val, index) => {\n        if (val.message.length < 5) {\n            prev[index] = { message: \"Todo message should be longer!\" };\n        }\n        return prev;\n    }, [] as any[]);\n    return {\n        // author: values.author.length < 3 ? \"Author name is too short.\" : undefined,\n        name: values.name.length < 3 ? \"Title is too short.\" : undefined,\n        todos: todoErrors.length > 0 ? todoErrors : undefined\n    };\n}\n","import \"./index.css\";\n\nimport React from \"react\";\nimport ReactDOM from \"react-dom\";\nimport App from \"./App\";\n\nReactDOM.render(<App />, document.getElementById(\"root\"));\n"],"sourceRoot":""}